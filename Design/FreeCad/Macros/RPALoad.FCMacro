# -*- coding: utf-8 -*-
#
# Name: RPALoad.FCMacro
# Purpose: Given a RPA txt contour file and some additional values, generate the freecad file for the nozzle.
#

# Macro Begin: C:\Users\joema\OneDrive\Desktop\freecad\RPALoad.FCMacro +++++++++++++++++++++++++++++++++++++++++++++++++
import FreeCAD
import PartDesign
import Draft
import PartDesignGui
import csv
import re
import numpy as np
# import scipy as sc
from scipy import interpolate
from PySide import QtGui






# Parameters
outfile = "out_profile.txt"







# Overall dimensions of regenerative cooling
regen_thickness = 10             # Total thickness of regenerative shell, i.e. we displace the profile "thickness" mm in the Y direction.
innerwall_thickness = 3          # Thickness of material between chamber wall and the channel (y-dirction)


# Channel dimensions
channel_bottom_reduction = 10    # How far back do we want to bring the channel section in mm
channel_top_reduction  = 10      # How far forward do we want to bring the channel section in mm
channel_count         = 20       # Number of channels
channel_width_top     = 3
channel_width_throat  = 2
channel_width_exit    = 3
channel_height_top    = 2
channel_height_throat = 2
channel_height_exit   = 2

# Coolant Entry
coolant_entry_ring_height = 10



# Coolant Exit
coolant_exit_ring_height = 10





# Variables
wire = []


doc = App.newDocument()

file_dialog = QtGui.QFileDialog()
rpa_file_path = file_dialog.getOpenFileName()[0]
print("\nImporting: " + rpa_file_path + "\n")


folder = os.path.dirname(rpa_file_path)
outfile_path = folder + "\\" + outfile
print("Generating new contour file: ", outfile_path)

p = re.compile('^#')
firstline = 0

points = []
num_points = 0
linenum = 0
# x, y list of points separated, so we can utilise numpy gradient
x_points = []
y_points = []
with open(outfile_path, 'w') as f:
	with open(rpa_file_path) as rpa_file:
		content = rpa_file.readlines()
		for line in content:
			if p.match(line):
				continue
			else:
				num_points = num_points + 1
				linenum = linenum + 1
				if firstline == 0:
					firstline = 1
					f.write("i    x     y" + "\n")
				# print(linenum, "     ", line.strip())
				f.write(str(linenum) + "     " + line.strip() + "\n")
				cells = line.split()
				x = cells[0]
				y = cells[1]
				x_points.append(float(x))
				y_points.append(float(y))
				points.append([x, y])

	# print("Added ", num_points, " to file")
	# Initialise function to find gradient
	curve_grad = np.gradient(y_points, x_points)

	for i in range(1, num_points+1):
		x = float(points[-i][0])
		y = float(points[-i][1])

		

		# Adding thickness to the y-direction is not what we want. The thickness is length of vector tangent to surface.
        # y = float(y) + thickness

		# While we are at it, we find out what the point is out outter wall of channel
		# First we need to find vector that is tangent to the point we are interested in.
		grad_vector = [1, curve_grad[-i]]
		grad_vector_unit = np.round(grad_vector / np.linalg.norm(grad_vector),8)
		# print(grad_vector_unit)

		# Then we want to find the vector that is orthogonal to this vector
		if grad_vector_unit[1] == 0:
			orthogonal_vector = [0, 1]
		else:
			orthogonal_vector = [1, - 1 / grad_vector_unit[1]]
			orthogonal_vector = np.round(orthogonal_vector / np.linalg.norm(orthogonal_vector), 8)

		# We want the vector always pointing up in the y-direction (there are two vectors that are perpendicular, and this is the one we want)
		if orthogonal_vector[1] < 0:
			orthogonal_vector[0] = -1 * orthogonal_vector[0]
			orthogonal_vector[1] = -1 * orthogonal_vector[1]


		# Find the new location / point.
		# v = innerwall_thickness * orthogonal_vector
		v = np.multiply(orthogonal_vector, regen_thickness)
		new_x = x + v[0]
		new_y = y + v[1]

		linenum = linenum + 1
		# print(linenum, "     ", x, "     ", y)
		f.write(str(linenum) + "     " + str(new_x) + "     " + str(new_y) + "\n")


	#linenum = linenum + 1
	#x = points[0][0]
	#y = points[0][1]
	#f.write(str(linenum) + "     " + str(x) + "     " + str(y) + "\n")

print("Created output file: ", outfile)


# this read the csv to generate the regenerative cooling unit.
with open(outfile_path) as csv_file:
	csv_reader = csv.DictReader(csv_file, delimiter=' ', skipinitialspace=True)
	line_count = 0
	for row in csv_reader:
		# for the first row print the headers
		if line_count == 0:
			print(f'Keys are: {", ".join(row)}\n')
			line_count += 1
		# for other rows extract the information
		x = row["x"]
		y = row["y"]

		# and create the geometry
		# print(x, " ", y)
		wire.append(FreeCAD.Vector(float(x),float(y),float(0))) # append the coordinates
		line_count += 1

	print(f'\nProcessed {line_count} lines.\n')
	wire_object = Draft.makeWire(wire,closed=True,face=False,support=None)   # create the wire open


doc.recompute()

sketch_nozzle = Draft.make_sketch([wire_object], autoconstraints=True, delete=False, radiusPrecision=0)
doc.recompute()

doc.addObject('PartDesign::Body','Body')
doc.Body.Group = [sketch_nozzle]
doc.recompute()

doc.getObject('Sketch').Support = (doc.getObject('XY_Plane'), [''])
doc.getObject('Sketch').MapMode = 'FlatFace'
doc.recompute()



doc.getObject('Body').newObject('PartDesign::Revolution','Revolution')
doc.getObject('Revolution').Profile = sketch_nozzle
doc.getObject('Revolution').ReferenceAxis = (doc.getObject('X_Axis'), [''])
doc.getObject('Revolution').Angle = 360.0
doc.getObject('Revolution').Reversed = 1
doc.getObject('Sketch').Visibility = False
doc.recompute()



# this read the csv to generate the channels
# NOTE, we need to take into account the channel specs...this is to allow us to use the profile to generate 
# channels that match curvature of the nozzle profile.
# This takes 3 steps
# - load data into array  - This was done above and is in list: points
# - process array of data to conform with design settings
# - Parse


channel_points = []  # Holds points for single channel


# Get min and max X points.
for i in range(0, num_points):
	if i == 0:
		min_x = float(points[i][0])
		max_x = float(min_x)
	else:
		min_x = min(min_x, float(points[i][0]))
		max_x = max(max_x, float(points[i][0]))

    
print("Min x: ", min_x)
print("Max x: ", max_x)






# Start generating "inner" points of channel
channel_points = []           # Points closest to Combustion chamber

channel_points_raw = []       # Where we hold the points in raw format, so we can go over this to generate other points.
channel_points_raw_x = []
channel_points_raw_y = []
channel_points_outter = []    # Points furtherest from Combustion chamber
num_points_channel = 0
for i in range(0, num_points-1):
	x =  float(points[i][0])
	y =  float(points[i][1])

	if i != num_points:
		next_x =  float(points[i+1][0])
		next_y =  float(points[i+1][1])
	
	
	# Make sure we don't breach top of nozzle with channel
	if x < min_x + channel_top_reduction:
		if next_x < min_x + channel_top_reduction:
			continue
		else:
			f = interpolate.interp1d([x, next_x], [y, next_y])
			new_x = min_x + channel_top_reduction
			new_y = f(new_x)
			# Make sure we don't breach bottom of nozzle with channel
	elif x > max_x - channel_bottom_reduction:
		if prev_x < max_x - channel_bottom_reduction:
			f = interpolate.interp1d([prev_x, x], [prev_y, y])
			new_x = max_x - channel_bottom_reduction
			new_y = f(new_x)
		else:
			continue
	else:
		new_x = x
		new_y = y



	# Add this point to the channel Wall
	# new_y = new_y + innerwall_thickness
	# channel_points.append(FreeCAD.Vector(float(new_x),float(new_y),float(0))) # append the coordinates
	# print("INNER Points: ", new_x, ", ", new_y)


	
	# While we are at it, we find out what the point is out outter wall of channel
	# First we need to find vector that is tangent to the point we are interested in.
	grad_vector = [1, curve_grad[i]]
	grad_vector_unit = np.round(grad_vector / np.linalg.norm(grad_vector),8)

	# Then we want to find the vector that is orthogonal to this vector
	if grad_vector_unit[1] == 0:
		orthogonal_vector = [0, 1]
	else:
		orthogonal_vector = [1, - 1 / grad_vector_unit[1]]
		orthogonal_vector = np.round(orthogonal_vector / np.linalg.norm(orthogonal_vector), 8)

	# We want the vector always pointing up in the y-direction (there are two vectors that are perpendicular, and this is the one we want)
	if orthogonal_vector[1] < 0:
		orthogonal_vector[0] = -1 * orthogonal_vector[0]
		orthogonal_vector[1] = -1 * orthogonal_vector[1]


	# Find the new location / point.
	# v = innerwall_thickness * orthogonal_vector
	v = np.multiply(orthogonal_vector, innerwall_thickness)
	new_x = new_x + v[0]
	new_y = new_y + v[1]


	# We push data on to these lists to make the step of creating the outer edge of channel a little less complex.
	channel_points_raw_x.append(float(new_x))
	channel_points_raw_y.append(float(new_y))
	channel_points_raw.append([float(new_x),float(new_y)])
	num_points_channel  = num_points_channel  + 1
	
	# now add points to List that will be used to do the drawin.g
	channel_points.append(FreeCAD.Vector(float(new_x),float(new_y),float(0))) # append the coordinates


	prev_x = x
	prev_y = y



# Start generating "outer" points of channel
channel_outer_points_raw = []
curve_grad = np.gradient(channel_points_raw_y, channel_points_raw_x)
for i in range(1, num_points_channel +1):
	x = float(channel_points_raw[-i][0])
	y = float(channel_points_raw[-i][1])

	# Calculate channel height at this point along
	channel_height = channel_height_top

	# Adding thickness to the y-direction is not what we want. The thickness is length of vector tangent to surface.
	# y = float(y) + thickness
	# While we are at it, we find out what the point is out outter wall of channel
	# First we need to find vector that is tangent to the point we are interested in.
	grad_vector = [1, curve_grad[-i]]
	grad_vector_unit = np.round(grad_vector / np.linalg.norm(grad_vector),8)
	# print(grad_vector_unit)

	# Then we want to find the vector that is orthogonal to this vector
	if grad_vector_unit[1] == 0:
		orthogonal_vector = [0, 1]
	else:
		orthogonal_vector = [1, - 1 / grad_vector_unit[1]]
		orthogonal_vector = np.round(orthogonal_vector / np.linalg.norm(orthogonal_vector), 8)

	# We want the vector always pointing up in the y-direction (there are two vectors that are perpendicular, and this is the one we want)
	if orthogonal_vector[1] < 0:
		orthogonal_vector[0] = -1 * orthogonal_vector[0]
		orthogonal_vector[1] = -1 * orthogonal_vector[1]


	# Find the new location / point.
	# v = innerwall_thickness * orthogonal_vector
	v = np.multiply(orthogonal_vector, channel_height)
	new_x = x + v[0]
	new_y = y + v[1]

	linenum = linenum + 1
	# print(linenum, "     ", x, "     ", y)
	# f.write(str(linenum) + "     " + str(new_x) + "     " + str(new_y) + "\n")
	channel_points.append(FreeCAD.Vector(float(new_x),float(new_y),float(0))) # append the coordinates
	channel_outer_points_raw.append([float(new_x),float(new_y)])




channel_object = Draft.makeWire(channel_points,closed=True,face=False,support=None)   # create the wire open
doc.recompute()

sketch_channel = Draft.make_sketch([channel_object], autoconstraints=True, delete=False, radiusPrecision=0)
doc.recompute()


print(f'\nProcessed {line_count} lines.\n')

# Calculate angle we must revolve the sketch to ensure we get the channel width desired.
top_radius = float(y_points[0]) + innerwall_thickness
circumference = 2 * np.pi * top_radius
angle_rotation = 360 * channel_width_top / circumference

print("Radius: ", top_radius)
print("Circumference: ", circumference)
print("ar: ", angle_rotation)


# Create the 3-d representation of the channel
doc.addObject('PartDesign::Body','BodyChannel')
doc.BodyChannel.Group = [sketch_channel]
doc.recompute()

sketch_channel.Support = (doc.getObject('XY_Plane'), [''])
sketch_channel.MapMode = 'FlatFace'
doc.recompute()



doc.getObject('BodyChannel').newObject('PartDesign::Revolution','RevolutionChannel')
doc.getObject('RevolutionChannel').Profile = sketch_channel
doc.getObject('RevolutionChannel').ReferenceAxis = (doc.getObject('X_Axis'), [''])
doc.getObject('RevolutionChannel').Angle = angle_rotation
doc.getObject('RevolutionChannel').Reversed = 1
sketch_channel.Visibility = False
doc.recompute()




# Make channel_count copies and rotate these.
RegenCoolingChannels = App.ActiveDocument.addObject("App::DocumentObjectGroup", "RegenCoolingChannels")
RegenCoolingChannels.addObjects([doc.getObject('BodyChannel')])
for i in range(1,channel_count):
	channel_copy = doc.copyObject(doc.getObject('BodyChannel'), True)
	angle = (360 / channel_count) * i
	channel_copy.Placement=App.Placement(App.Vector(0,0,0), App.Rotation(App.Vector(1,0,0),angle), App.Vector(0,0,0))
	RegenCoolingChannels.addObjects([channel_copy])



# Add the coolant exit
doc.addObject("Part::Cylinder","Cylinder_1")
doc.ActiveObject.Label = "Cylinder_coolant_exit_build1"
doc.recompute()
doc.getObject('Cylinder_1').Radius = top_radius
doc.getObject('Cylinder_1').Height = coolant_exit_ring_height


doc.addObject("Part::Cylinder","Cylinder_2")
doc.ActiveObject.Label = "Cylinder_coolant_exit_build2"
doc.recompute()
doc.getObject('Cylinder_2').Radius = top_radius + channel_height_top
doc.getObject('Cylinder_2').Height = coolant_exit_ring_height

doc.addObject("Part::Cut","Coolant_exit_ring")
doc.Coolant_exit_ring.Base = doc.Cylinder_2
doc.Coolant_exit_ring.Tool = doc.Cylinder_1
doc.recompute()


# Next we rotate and move this into place
displacement = coolant_exit_ring_height + channel_top_reduction
angle_rotation = -90
# doc.Coolant_exit_ring.Placement=App.Placement(App.Vector(0,0,0), App.Rotation(App.Vector(0,1,0),-90), App.Vector(0,0,0))
doc.Coolant_exit_ring.Placement=App.Placement(App.Vector(displacement,0,0), App.Rotation(App.Vector(0,1,0),angle_rotation), App.Vector(0,0,0))

RegenCoolingChannels.addObjects([doc.getObject('Coolant_exit_ring')])




# Add the coolant entry
# We use the channel data at exit and work "back". Because the angle of the exit is normally small
# we use the x-displacement, not the curved length as the height of ring
#
# This is the INNER part of the coolant exit ring. (part 1 of 3)
coolant_exit_ring_points = []
for i in range(1, num_points_channel +1):
	x = float(channel_points_raw[-i][0])
	y = float(channel_points_raw[-i][1])
	
	if i == 1:
		x_start = x

	if x_start - x > coolant_entry_ring_height:
		f = interpolate.interp1d([prev_x, x], [prev_y, y])
		xx = x_start - coolant_entry_ring_height
		yy = f(xx)
		coolant_exit_ring_points.append([xx, yy])
		break
	else:
		xx = x
		yy = y

	coolant_exit_ring_points.append([xx, yy])
	# print("added xx, yy: ", xx, ", ", yy)



	prev_x = x
	prev_y = y


# Reverse list, so we can continue to add points in
coolant_exit_ring_points.reverse()



# This is the OUTER part of the coolant exit ring. (part 2 of 3)
for i in range(0, num_points_channel):
	x = float(channel_outer_points_raw[i][0])
	y = float(channel_outer_points_raw[i][1])
	
	if i == 0:
		x_start = x

	if x_start - x > coolant_entry_ring_height:
		f = interpolate.interp1d([prev_x, x], [prev_y, y])
		xx = x_start - coolant_entry_ring_height
		yy = f(xx)
		coolant_exit_ring_points.append([xx, yy])
		break
	else:
		xx = x
		yy = y

	coolant_exit_ring_points.append([xx, yy])
	# print("added xx, yy: ", xx, ", ", yy)

	prev_x = x
	prev_y = y


# print(coolant_exit_ring_points)


# Now that we have Inner and Outer points, we create a sketch.
coolant_entry_ring = []
for i in range(1, len(coolant_exit_ring_points)):
	x = coolant_exit_ring_points[i][0]
	y = coolant_exit_ring_points[i][1]
	coolant_entry_ring.append(FreeCAD.Vector(x,y,float(0))) # append the coordinates


coolant_entry_ring_object = Draft.makeWire(coolant_entry_ring,closed=True,face=False,support=None)   # create the wire open
doc.recompute()

sketch_coolant_entry_ring = Draft.make_sketch([coolant_entry_ring_object], autoconstraints=True, delete=False, radiusPrecision=0)
doc.recompute()


# Revolve sketch to finish off coolant entry ring
doc.addObject('PartDesign::Body','Coolant_entry_ring_body')
doc.Coolant_entry_ring_body.Group = [sketch_coolant_entry_ring]

sketch_coolant_entry_ring.Support = (doc.getObject('XY_Plane040'), [''])
sketch_coolant_entry_ring.MapMode = 'FlatFace'
doc.recompute()

doc.getObject('Coolant_entry_ring_body').newObject('PartDesign::Revolution','Coolant_entry_ring_revolution')
doc.getObject('Coolant_entry_ring_revolution').Profile = sketch_coolant_entry_ring
doc.getObject('Coolant_entry_ring_revolution').ReferenceAxis = (doc.getObject('X_Axis040'), [''])
doc.getObject('Coolant_entry_ring_revolution').Angle = 360.000000
doc.getObject('Coolant_entry_ring_revolution').Midplane = 0
doc.getObject('Coolant_entry_ring_revolution').Reversed = 0
doc.recompute()

sketch_coolant_entry_ring.Visibility = False
doc.recompute()



