# -*- coding: utf-8 -*-
#
# Name: RPALoad.FCMacro
# Purpose: Given a RPA txt contour file and some additional values, generate the freecad file for the nozzle.
#

# Macro Begin: C:\Users\joema\OneDrive\Desktop\freecad\RPALoad.FCMacro +++++++++++++++++++++++++++++++++++++++++++++++++
import FreeCAD
import PartDesign
import Draft
import PartDesignGui
import csv
import re
import numpy as np
import math
# import scipy as sc
from scipy import interpolate
from PySide import QtGui






# Parameters
outfile = "out_profile.txt"







# Overall dimensions of regenerative cooling
regen_thickness = 10             # Total thickness of regenerative shell, i.e. we displace the profile "thickness" mm in the Y direction.
innerwall_thickness = 3          # Thickness of material between chamber wall and the channel (y-dirction)


# Channel dimensions
channel_bottom_reduction = 10    # How far back do we want to bring the channel section in mm
channel_top_reduction  = 10      # How far forward do we want to bring the channel section in mm
channel_count         = 20       # Number of channels
channel_width_top     = 3
channel_width_throat  = 2
channel_width_bottom  = 3
channel_height_top    = 2
channel_height_throat = 4
channel_height_bottom = 2

# Coolant Entry
coolant_entry_ring_height     = 10  # Height if ring, that connects all the channels
coolant_entry_torus_thickness = 3   # Thickness of torus metal manifold at coolant exit (top of motor)


# Coolant Exit
coolant_exit_ring_height    = 10    # Height if ring, that connects all the channels
coolant_exit_torus_thickness = 3    # Thickness of torus metal manifold at coolant exit (top of motor)




# Variables
wire = []
channel_throat_radius = 99999       # This is radius to channel wall, closest to combustion chamber.  # Intentially set too high. Is deduced later.
channel_top_radius    = 0           # Radius of channel wall at the top of motor
channel_bottom_radius = 0           # Radius of channel wall at the bottom of motor

doc = App.newDocument()


# Make Groups
RegenCoolingChannels = App.ActiveDocument.addObject("App::DocumentObjectGroup", "RegenCoolingChannels")
MotorGroup = App.ActiveDocument.addObject("App::DocumentObjectGroup", "MotorGroup")




file_dialog = QtGui.QFileDialog()
rpa_file_path = file_dialog.getOpenFileName()[0]
print("\nImporting: " + rpa_file_path + "\n")


folder = os.path.dirname(rpa_file_path)
outfile_path = folder + "\\" + outfile
print("Generating new contour file: ", outfile_path)

p = re.compile('^#')
firstline = 0

points = []
num_points = 0
linenum = 0
# x, y list of points separated, so we can utilise numpy gradient
x_points = []
y_points = []
with open(outfile_path, 'w') as f:
	with open(rpa_file_path) as rpa_file:
		content = rpa_file.readlines()
		for line in content:
			if p.match(line):
				continue
			else:
				num_points = num_points + 1
				linenum = linenum + 1
				if firstline == 0:
					firstline = 1
					f.write("i    x     y" + "\n")
				# print(linenum, "     ", line.strip())
				f.write(str(linenum) + "     " + line.strip() + "\n")
				cells = line.split()
				x = cells[0]
				y = cells[1]
				x_points.append(float(x))
				y_points.append(float(y))
				points.append([x, y])

	# print("Added ", num_points, " to file")
	# Initialise function to find gradient
	curve_grad = np.gradient(y_points, x_points)

	for i in range(1, num_points+1):
		x = float(points[-i][0])
		y = float(points[-i][1])

		

		# Adding thickness to the y-direction is not what we want. The thickness is length of vector tangent to surface.
        # y = float(y) + thickness

		# While we are at it, we find out what the point is out outter wall of channel
		# First we need to find vector that is tangent to the point we are interested in.
		grad_vector = [1, curve_grad[-i]]
		grad_vector_unit = np.round(grad_vector / np.linalg.norm(grad_vector),8)
		# print(grad_vector_unit)

		# Then we want to find the vector that is orthogonal to this vector
		if grad_vector_unit[1] == 0:
			orthogonal_vector = [0, 1]
		else:
			orthogonal_vector = [1, - 1 / grad_vector_unit[1]]
			orthogonal_vector = np.round(orthogonal_vector / np.linalg.norm(orthogonal_vector), 8)

		# We want the vector always pointing up in the y-direction (there are two vectors that are perpendicular, and this is the one we want)
		if orthogonal_vector[1] < 0:
			orthogonal_vector[0] = -1 * orthogonal_vector[0]
			orthogonal_vector[1] = -1 * orthogonal_vector[1]


		# Find the new location / point.
		# v = innerwall_thickness * orthogonal_vector
		v = np.multiply(orthogonal_vector, regen_thickness)
		new_x = x + v[0]
		new_y = y + v[1]

		linenum = linenum + 1
		# print(linenum, "     ", x, "     ", y)
		f.write(str(linenum) + "     " + str(new_x) + "     " + str(new_y) + "\n")


	#linenum = linenum + 1
	#x = points[0][0]
	#y = points[0][1]
	#f.write(str(linenum) + "     " + str(x) + "     " + str(y) + "\n")

print("Created output file: ", outfile)


# this read the csv to generate the regenerative cooling unit.
with open(outfile_path) as csv_file:
	csv_reader = csv.DictReader(csv_file, delimiter=' ', skipinitialspace=True)
	line_count = 0
	for row in csv_reader:
		# for the first row print the headers
		if line_count == 0:
			print(f'Keys are: {", ".join(row)}\n')
			line_count += 1
		# for other rows extract the information
		x = row["x"]
		y = row["y"]

		# and create the geometry
		# print(x, " ", y)
		wire.append(FreeCAD.Vector(float(x),float(y),float(0))) # append the coordinates
		line_count += 1

	print(f'\nProcessed {line_count} lines.\n')
	wire_object = Draft.makeWire(wire,closed=True,face=False,support=None)   # create the wire open


doc.recompute()

sketch_nozzle = Draft.make_sketch([wire_object], autoconstraints=True, delete=False, radiusPrecision=0)
doc.recompute()

doc.addObject('PartDesign::Body','MotorBody')
doc.MotorBody.Group = [sketch_nozzle]
doc.recompute()

doc.getObject('Sketch').Support = (doc.getObject('XY_Plane'), [''])
doc.getObject('Sketch').MapMode = 'FlatFace'
doc.recompute()



doc.getObject('MotorBody').newObject('PartDesign::Revolution','Revolution')
doc.getObject('Revolution').Profile = sketch_nozzle
doc.getObject('Revolution').ReferenceAxis = (doc.getObject('X_Axis'), [''])
doc.getObject('Revolution').Angle = 360.0
doc.getObject('Revolution').Reversed = 1
doc.getObject('Sketch').Visibility = False
doc.recompute()


wire_object.Visibility = False
doc.recompute()



MotorGroup.addObjects([doc.getObject('MotorBody')])



# this read the csv to generate the channels
# NOTE, we need to take into account the channel specs...this is to allow us to use the profile to generate 
# channels that match curvature of the nozzle profile.
# This takes 3 steps
# - load data into array  - This was done above and is in list: points
# - process array of data to conform with design settings
# - Parse


channel_points = []  # Holds points for single channel


# Get min and max X points.
for i in range(0, num_points):
	if i == 0:
		min_x = float(points[i][0])
		max_x = float(min_x)
	else:
		min_x = min(min_x, float(points[i][0]))
		max_x = max(max_x, float(points[i][0]))

    
print("Min x: ", min_x)
print("Max x: ", max_x)






# Start generating "inner" points of channel
channel_points = []           # Points closest to Combustion chamber

channel_points_raw = []       # Where we hold the points in raw format, so we can go over this to generate other points.
channel_points_raw_x = []
channel_points_raw_y = []
channel_points_outter = []    # Points furtherest from Combustion chamber
num_points_channel = 0
for i in range(0, num_points-1):
	x =  float(points[i][0])
	y =  float(points[i][1])

	if i != num_points:
		next_x =  float(points[i+1][0])
		next_y =  float(points[i+1][1])
	
	
	# Make sure we don't breach top of nozzle with channel
	if x < min_x + channel_top_reduction:
		if next_x < min_x + channel_top_reduction:
			continue
		else:
			f = interpolate.interp1d([x, next_x], [y, next_y])
			new_x = min_x + channel_top_reduction
			new_y = f(new_x)
			# Make sure we don't breach bottom of nozzle with channel
	elif x > max_x - channel_bottom_reduction:
		if prev_x < max_x - channel_bottom_reduction:
			f = interpolate.interp1d([prev_x, x], [prev_y, y])
			new_x = max_x - channel_bottom_reduction
			new_y = f(new_x)
		else:
			continue
	else:
		new_x = x
		new_y = y



	# Add this point to the channel Wall
	# new_y = new_y + innerwall_thickness
	# channel_points.append(FreeCAD.Vector(float(new_x),float(new_y),float(0))) # append the coordinates
	# print("INNER Points: ", new_x, ", ", new_y)


	
	# While we are at it, we find out what the point is out outter wall of channel
	# First we need to find vector that is tangent to the point we are interested in.
	grad_vector = [1, curve_grad[i]]
	grad_vector_unit = np.round(grad_vector / np.linalg.norm(grad_vector),8)

	# Then we want to find the vector that is orthogonal to this vector
	if grad_vector_unit[1] == 0:
		orthogonal_vector = [0, 1]
	else:
		orthogonal_vector = [1, - 1 / grad_vector_unit[1]]
		orthogonal_vector = np.round(orthogonal_vector / np.linalg.norm(orthogonal_vector), 8)

	# We want the vector always pointing up in the y-direction (there are two vectors that are perpendicular, and this is the one we want)
	if orthogonal_vector[1] < 0:
		orthogonal_vector[0] = -1 * orthogonal_vector[0]
		orthogonal_vector[1] = -1 * orthogonal_vector[1]


	# Find the new location / point.
	# v = innerwall_thickness * orthogonal_vector
	v = np.multiply(orthogonal_vector, innerwall_thickness)
	new_x = new_x + v[0]
	new_y = new_y + v[1]


	# We push data on to these lists to make the step of creating the outer edge of channel a little less complex.
	channel_points_raw_x.append(float(new_x))
	channel_points_raw_y.append(float(new_y))
	channel_points_raw.append([float(new_x),float(new_y)])
	channel_throat_radius = min(channel_throat_radius, float(new_y))
	num_points_channel  = num_points_channel  + 1
	
	# now add points to List that will be used to do the drawin.g
	channel_points.append(FreeCAD.Vector(float(new_x),float(new_y),float(0))) # append the coordinates


	prev_x = x
	prev_y = y

# Get radius of channel at top and bottom. Required later for calculating the height of channel
channel_bottom_radius = channel_points_raw_y[0]
channel_top_radius    = channel_points_raw_y[len(channel_points_raw_y)-1]


# Start generating "outer" points of channel
channel_outer_points_raw = []
curve_grad = np.gradient(channel_points_raw_y, channel_points_raw_x)
location   = 2    # 2 is for below throat, near exist   #1 is for above throat
for i in range(1, num_points_channel +1):
	x = float(channel_points_raw[-i][0])
	y = float(channel_points_raw[-i][1])

	# Work out if are moving from the bottom of nozzle to top of nozzle (combustion chamber)
	if prev_y  < y:
		location = 1

	if location == 2:
		r = (y - channel_throat_radius)/(channel_bottom_radius - channel_throat_radius)
		channel_height = channel_height_bottom * r  +  channel_height_throat * (1 - r)
	elif location == 1:
		r = (y - channel_throat_radius)/(channel_top_radius - channel_throat_radius)
		channel_height = channel_height_top * r  +  channel_height_throat * (1 - r)
	else:
		print("ERROR. UNEXPECTED LOCATION: ", location)


	# Calculate channel height at this point along
	# channel_height = channel_height_top

	# Adding thickness to the y-direction is not what we want. The thickness is length of vector tangent to surface.
	# y = float(y) + thickness
	# While we are at it, we find out what the point is out outter wall of channel
	# First we need to find vector that is tangent to the point we are interested in.
	grad_vector = [1, curve_grad[-i]]
	grad_vector_unit = np.round(grad_vector / np.linalg.norm(grad_vector),8)
	# print(grad_vector_unit)

	# Then we want to find the vector that is orthogonal to this vector
	if grad_vector_unit[1] == 0:
		orthogonal_vector = [0, 1]
	else:
		orthogonal_vector = [1, - 1 / grad_vector_unit[1]]
		orthogonal_vector = np.round(orthogonal_vector / np.linalg.norm(orthogonal_vector), 8)

	# We want the vector always pointing up in the y-direction (there are two vectors that are perpendicular, and this is the one we want)
	if orthogonal_vector[1] < 0:
		orthogonal_vector[0] = -1 * orthogonal_vector[0]
		orthogonal_vector[1] = -1 * orthogonal_vector[1]


	# Find the new location / point.
	# v = innerwall_thickness * orthogonal_vector
	v = np.multiply(orthogonal_vector, channel_height)
	new_x = x + v[0]
	new_y = y + v[1]

	linenum = linenum + 1
	# print(linenum, "     ", x, "     ", y)
	# f.write(str(linenum) + "     " + str(new_x) + "     " + str(new_y) + "\n")
	channel_points.append(FreeCAD.Vector(float(new_x),float(new_y),float(0))) # append the coordinates
	channel_outer_points_raw.append([float(new_x),float(new_y)])

	prev_x = x
	prev_y = y


channel_object = Draft.makeWire(channel_points,closed=True,face=False,support=None)   # create the wire open
doc.recompute()

sketch_channel = Draft.make_sketch([channel_object], autoconstraints=True, delete=False, radiusPrecision=0)
doc.recompute()


print(f'\nProcessed {line_count} lines.\n')

# Calculate angle we must revolve the sketch to ensure we get the channel width desired.
top_radius = float(y_points[0]) + innerwall_thickness
circumference = 2 * np.pi * top_radius
angle_rotation = 360 * channel_width_top / circumference

print("Radius: ", top_radius)
print("Circumference: ", circumference)
print("ar: ", angle_rotation)


# Create the 3-d representation of the channel
doc.addObject('PartDesign::Body','BodyChannel')
doc.BodyChannel.Group = [sketch_channel]
doc.recompute()

sketch_channel.Support = (doc.getObject('XY_Plane'), [''])
sketch_channel.MapMode = 'FlatFace'
doc.recompute()



doc.getObject('BodyChannel').newObject('PartDesign::Revolution','RevolutionChannel')
doc.getObject('RevolutionChannel').Profile = sketch_channel
doc.getObject('RevolutionChannel').ReferenceAxis = (doc.getObject('X_Axis'), [''])
doc.getObject('RevolutionChannel').Angle = angle_rotation
doc.getObject('RevolutionChannel').Reversed = 1
sketch_channel.Visibility = False
doc.recompute()



channel_object.Visibility = False
doc.recompute()




# Make channel_count copies and rotate these.
RegenCoolingChannels.addObjects([doc.getObject('BodyChannel')])
for i in range(1,channel_count):
	channel_copy = doc.copyObject(doc.getObject('BodyChannel'), True)
	angle = (360 / channel_count) * i
	channel_copy.Placement=App.Placement(App.Vector(0,0,0), App.Rotation(App.Vector(1,0,0),angle), App.Vector(0,0,0))
	RegenCoolingChannels.addObjects([channel_copy])



# Add the coolant exit
doc.addObject("Part::Cylinder","Cylinder_1")
doc.ActiveObject.Label = "Cylinder_coolant_exit_build1"
doc.recompute()
doc.getObject('Cylinder_1').Radius = top_radius
doc.getObject('Cylinder_1').Height = coolant_exit_ring_height


doc.addObject("Part::Cylinder","Cylinder_2")
doc.ActiveObject.Label = "Cylinder_coolant_exit_build2"
doc.recompute()
doc.getObject('Cylinder_2').Radius = top_radius + channel_height_top
doc.getObject('Cylinder_2').Height = coolant_exit_ring_height

doc.addObject("Part::Cut","Coolant_exit_ring")
doc.Coolant_exit_ring.Base = doc.Cylinder_2
doc.Coolant_exit_ring.Tool = doc.Cylinder_1
doc.recompute()



# Next we rotate and move this into place
displacement = coolant_exit_ring_height + channel_top_reduction
angle_rotation = -90
# doc.Coolant_exit_ring.Placement=App.Placement(App.Vector(0,0,0), App.Rotation(App.Vector(0,1,0),-90), App.Vector(0,0,0))
doc.Coolant_exit_ring.Placement=App.Placement(App.Vector(displacement,0,0), App.Rotation(App.Vector(0,1,0),angle_rotation), App.Vector(0,0,0))

RegenCoolingChannels.addObjects([doc.getObject('Coolant_exit_ring')])




########################################################################
# Add the coolant entry ring
# We use the channel data at exit and work "back". Because the angle of the exit is normally small
# we use the x-displacement, not the curved length as the height of ring
#
# This is the INNER part of the coolant exit ring. (part 1 of 3)
coolant_exit_ring_points = []
for i in range(1, num_points_channel +1):
	x = float(channel_points_raw[-i][0])
	y = float(channel_points_raw[-i][1])
	
	if i == 1:
		x_start = x

	if x_start - x > coolant_entry_ring_height:
		f = interpolate.interp1d([prev_x, x], [prev_y, y])
		xx = x_start - coolant_entry_ring_height
		yy = f(xx)
		coolant_exit_ring_points.append([xx, yy])
		break
	else:
		xx = x
		yy = y

	coolant_exit_ring_points.append([xx, yy])
	# print("added xx, yy: ", xx, ", ", yy)



	prev_x = x
	prev_y = y


# Reverse list, so we can continue to add points in
coolant_exit_ring_points.reverse()



# This is the OUTER part of the coolant exit ring. (part 2 of 3)
for i in range(0, num_points_channel):
	x = float(channel_outer_points_raw[i][0])
	y = float(channel_outer_points_raw[i][1])
	
	if i == 0:
		x_start = x

	if x_start - x > coolant_entry_ring_height:
		f = interpolate.interp1d([prev_x, x], [prev_y, y])
		xx = x_start - coolant_entry_ring_height
		yy = f(xx)
		coolant_exit_ring_points.append([xx, yy])
		break
	else:
		xx = x
		yy = y

	coolant_exit_ring_points.append([xx, yy])
	# print("added xx, yy: ", xx, ", ", yy)

	prev_x = x
	prev_y = y


# print(coolant_exit_ring_points)


# Now that we have Inner and Outer points, we create a sketch.
coolant_entry_ring = []
for i in range(1, len(coolant_exit_ring_points)):
	x = coolant_exit_ring_points[i][0]
	y = coolant_exit_ring_points[i][1]
	coolant_entry_ring.append(FreeCAD.Vector(x,y,float(0))) # append the coordinates


coolant_entry_ring_object = Draft.makeWire(coolant_entry_ring,closed=True,face=False,support=None)   # create the wire open
doc.recompute()

sketch_coolant_entry_ring = Draft.make_sketch([coolant_entry_ring_object], autoconstraints=True, delete=False, radiusPrecision=0)
doc.recompute()


# Revolve sketch to finish off coolant entry ring
doc.addObject('PartDesign::Body','Coolant_entry_ring_body')
doc.Coolant_entry_ring_body.Group = [sketch_coolant_entry_ring]

sketch_coolant_entry_ring.Support = (doc.getObject('XY_Plane040'), [''])
sketch_coolant_entry_ring.MapMode = 'FlatFace'
doc.recompute()

doc.getObject('Coolant_entry_ring_body').newObject('PartDesign::Revolution','Coolant_entry_ring_revolution')
doc.getObject('Coolant_entry_ring_revolution').Profile = sketch_coolant_entry_ring
doc.getObject('Coolant_entry_ring_revolution').ReferenceAxis = (doc.getObject('X_Axis040'), [''])
doc.getObject('Coolant_entry_ring_revolution').Angle = 360.000000
doc.getObject('Coolant_entry_ring_revolution').Midplane = 0
doc.getObject('Coolant_entry_ring_revolution').Reversed = 0
doc.recompute()

sketch_coolant_entry_ring.Visibility = False
doc.recompute()

coolant_entry_ring_object.Visibility = False
doc.recompute()


# Add to Regen Cooling components
RegenCoolingChannels.addObjects([doc.getObject('Coolant_entry_ring_body')])
doc.recompute()






######################################################################
# Half-Torus - Coolant cooling exit
doc.addObject("Part::Torus","Coolant_exit_Torus")
doc.ActiveObject.Label = "Coolant_exit_Torus"


doc.getObject('Coolant_exit_Torus').Radius1 = top_radius + channel_height_top
doc.getObject('Coolant_exit_Torus').Radius2 = coolant_exit_ring_height / 2
doc.getObject('Coolant_exit_Torus').Angle1 = '-90.00 deg'
doc.getObject('Coolant_exit_Torus').Angle2 = '90.00 deg'

displacement = channel_top_reduction + coolant_exit_ring_height / 2
angle_rotation = -90
doc.getObject('Coolant_exit_Torus').Placement=App.Placement(App.Vector(displacement,0,0), App.Rotation(App.Vector(0,1,0),angle_rotation), App.Vector(0,0,0))
doc.recompute()


# Add to Regen Cooling components
RegenCoolingChannels.addObjects([doc.getObject('Coolant_exit_Torus')])
doc.recompute()





######################################################################
# Coolant Entry 1/2 "torus shaped" object
# This is the 1/2 torus cavity that bounds the coolant entry ring.
coolant_entry_torus_points = []
for i in range(0, num_points_channel):
	x = float(channel_outer_points_raw[i][0])
	y = float(channel_outer_points_raw[i][1])
	
	if i == 0:
		x_start = x
		min_x = x
		max_x = x
		min_y = y
		max_y = y

	if x_start - x > coolant_entry_ring_height:
		f = interpolate.interp1d([prev_x, x], [prev_y, y])
		xx = x_start - coolant_entry_ring_height
		yy = f(xx)
		coolant_exit_ring_points.append([xx, yy])
		break
	else:
		xx = x
		yy = y

	min_x = min(min_x, xx)
	max_x = max(max_x, xx)
	min_y = min(min_y, yy)
	max_y = max(max_y, yy)
	coolant_entry_torus_points.append([xx, yy])
	print("added xx, yy: ", xx, ", ", yy)

	prev_x = x
	prev_y = y


# Now we find "mid-point" between (min_x, min_y) and (max_x, max_y)
f = interpolate.interp1d([min_x, max_x], [min_y, max_y])
middle_x = (min_x + max_x) / 2
middle_y = f(middle_x)
gradient_angle = math.atan((max_y - min_y) / (max_x - min_x)) * 180 / np.pi

print("middle_x, middle_y: ", middle_x, ", ", middle_y)
print("Angle of strip: ", gradient_angle)


coolant_entry_torus_points.reverse()

# Now we create approximation of a circule ( 5 degrees apart ) to make the "torus" like cavity at coolant entry.
step_size = 5   # number of degrees
# for i in range(step_size - gradient_angle, 180 - (step_size - gradient_angle), step_size):
positions = int(180 / step_size)
for i in range(1, positions - 1):
	angle = (i * step_size + gradient_angle) * (np.pi / 180)
	# print("i, Angle: " , i, ", ", angle)
	xx = middle_x + (coolant_entry_ring_height / 2) * math.cos(angle)
	yy = middle_y + (coolant_entry_ring_height / 2) * math.sin(angle)
	coolant_entry_torus_points.append([xx, yy])


# Now that we have Inner and Outer points, we create a sketch.
coolant_entry_torus = []
for i in range(0, len(coolant_entry_torus_points)):
	x = coolant_entry_torus_points[i][0]
	y = coolant_entry_torus_points[i][1]
	coolant_entry_torus.append(FreeCAD.Vector(x,y,float(0))) # append the coordinates


coolant_entry_torus_object = Draft.makeWire(coolant_entry_torus,closed=True,face=False,support=None)   # create the wire open
doc.recompute()

sketch_coolant_entry_torus = Draft.make_sketch([coolant_entry_torus_object], autoconstraints=True, delete=False, radiusPrecision=0)
doc.recompute()


# Revolve coolant entry torus sketch to finish off coolant entry ring
doc.addObject('PartDesign::Body','Coolant_entry_torus_body')
doc.Coolant_entry_torus_body.Group = [sketch_coolant_entry_torus]

sketch_coolant_entry_torus.Support = (doc.getObject('XY_Plane041'), [''])
sketch_coolant_entry_torus.MapMode = 'FlatFace'
doc.recompute()

doc.getObject('Coolant_entry_torus_body').newObject('PartDesign::Revolution','Coolant_entry_torus_revolution')
doc.getObject('Coolant_entry_torus_revolution').Profile = sketch_coolant_entry_torus
doc.getObject('Coolant_entry_torus_revolution').ReferenceAxis = (doc.getObject('X_Axis041'), [''])
doc.getObject('Coolant_entry_torus_revolution').Angle = 360.000000
doc.getObject('Coolant_entry_torus_revolution').Midplane = 0
doc.getObject('Coolant_entry_torus_revolution').Reversed = 0
doc.recompute()

sketch_coolant_entry_torus.Visibility = False
doc.recompute()

coolant_entry_torus_object.Visibility = False
doc.recompute()


# Add to Regen Cooling components
RegenCoolingChannels.addObjects([doc.getObject('Coolant_entry_torus_body')])
doc.recompute()







######################################################################
# Create Coolant Exit OUTSIDE Torus (Top of the motor)
# Half-Torus - Coolant cooling exit
doc.addObject("Part::Torus","Coolant_outside_exit_Torus")
doc.ActiveObject.Label = "Coolant_outside_exit_Torus"


doc.getObject('Coolant_outside_exit_Torus').Radius1 = top_radius + channel_height_top
doc.getObject('Coolant_outside_exit_Torus').Radius2 = coolant_exit_torus_thickness + coolant_exit_ring_height / 2
doc.getObject('Coolant_outside_exit_Torus').Angle1 = '-90.00 deg'
doc.getObject('Coolant_outside_exit_Torus').Angle2 = '90.00 deg'

displacement = channel_top_reduction + coolant_exit_ring_height / 2
angle_rotation = -90
doc.getObject('Coolant_outside_exit_Torus').Placement=App.Placement(App.Vector(displacement,0,0), App.Rotation(App.Vector(0,1,0),angle_rotation), App.Vector(0,0,0))
doc.recompute()


# Add to Regen Cooling components
MotorGroup.addObjects([doc.getObject('Coolant_outside_exit_Torus')])
doc.recompute()







######################################################################
# Create 1/2 "torus shaped" manifold that surrounds "torus shaped" cavity at Coolant entry point. (bottom of rocket motor)
coolant_outside_entry_torus_points = []
for i in range(0, num_points_channel):
	x = float(channel_outer_points_raw[i][0])
	y = float(channel_outer_points_raw[i][1])
	
	if i == 0:
		x_start = x
		min_x = x
		max_x = x
		min_y = y
		max_y = y

	if x_start - x > coolant_entry_ring_height:
		f = interpolate.interp1d([prev_x, x], [prev_y, y])
		xx = x_start - coolant_entry_ring_height
		yy = f(xx)
		coolant_outside_entry_torus_points.append([xx, yy])
		break
	else:
		xx = x
		yy = y

	min_x = min(min_x, xx)
	max_x = max(max_x, xx)
	min_y = min(min_y, yy)
	max_y = max(max_y, yy)
	coolant_outside_entry_torus_points.append([xx, yy])
	print("added xx, yy: ", xx, ", ", yy)

	prev_x = x
	prev_y = y


# Now we find "mid-point" between (min_x, min_y) and (max_x, max_y)
f = interpolate.interp1d([min_x, max_x], [min_y, max_y])
middle_x = (min_x + max_x) / 2
middle_y = f(middle_x)
gradient_angle = math.atan((max_y - min_y) / (max_x - min_x)) * 180 / np.pi

print("middle_x, middle_y: ", middle_x, ", ", middle_y)
print("Angle of strip: ", gradient_angle)


coolant_outside_entry_torus_points.reverse()

# Now we create approximation of a circule ( 5 degrees apart ) to make the "torus" like cavity at coolant entry.
step_size = 5   # number of degrees
# for i in range(step_size - gradient_angle, 180 - (step_size - gradient_angle), step_size):
positions = int(180 / step_size)
for i in range(0, positions):
	angle = (i * step_size + gradient_angle) * (np.pi / 180)
	# print("i, Angle: " , i, ", ", angle)
	xx = middle_x + (coolant_entry_torus_thickness + coolant_entry_ring_height / 2) * math.cos(angle)
	yy = middle_y + (coolant_entry_torus_thickness + coolant_entry_ring_height / 2) * math.sin(angle)
	coolant_outside_entry_torus_points.append([xx, yy])


# Now that we have Inner and Outer points, we create a sketch.
coolant_outside_entry_torus = []
for i in range(0, len(coolant_entry_torus_points)):
	x = coolant_outside_entry_torus_points[i][0]
	y = coolant_outside_entry_torus_points[i][1]
	coolant_outside_entry_torus.append(FreeCAD.Vector(x,y,float(0))) # append the coordinates


coolant_outside_entry_torus_object = Draft.makeWire(coolant_outside_entry_torus,closed=True,face=False,support=None)   # create the wire open
doc.recompute()

sketch_coolant_outside_entry_torus = Draft.make_sketch([coolant_outside_entry_torus_object], autoconstraints=True, delete=False, radiusPrecision=0)
doc.recompute()


# Revolve coolant entry torus sketch to finish off coolant entry ring
doc.addObject('PartDesign::Body','Coolant_outside_entry_torus_body')
doc.Coolant_outside_entry_torus_body.Group = [sketch_coolant_outside_entry_torus]

sketch_coolant_outside_entry_torus.Support = (doc.getObject('XY_Plane042'), [''])
sketch_coolant_outside_entry_torus.MapMode = 'FlatFace'
doc.recompute()

doc.getObject('Coolant_outside_entry_torus_body').newObject('PartDesign::Revolution','Coolant_outside_entry_torus_revolution')
doc.getObject('Coolant_outside_entry_torus_revolution').Profile = sketch_coolant_outside_entry_torus
doc.getObject('Coolant_outside_entry_torus_revolution').ReferenceAxis = (doc.getObject('X_Axis042'), [''])
doc.getObject('Coolant_outside_entry_torus_revolution').Angle = 360.000000
doc.getObject('Coolant_outside_entry_torus_revolution').Midplane = 0
doc.getObject('Coolant_outside_entry_torus_revolution').Reversed = 0
doc.recompute()

sketch_coolant_outside_entry_torus.Visibility = False
doc.recompute()

coolant_outside_entry_torus_object.Visibility = False
doc.recompute()


# Add to Regen Cooling components
MotorGroup.addObjects([doc.getObject('Coolant_outside_entry_torus_body')])
doc.recompute()



