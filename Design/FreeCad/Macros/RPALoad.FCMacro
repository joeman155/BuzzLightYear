# -*- coding: utf-8 -*-
#
# Name: RPALoad.FCMacro
# Purpose: Given a RPA txt contour file and some additional values, generate the freecad file for the nozzle.
#

# Macro Begin: C:\Users\joema\OneDrive\Desktop\freecad\RPALoad.FCMacro +++++++++++++++++++++++++++++++++++++++++++++++++
import FreeCAD
import PartDesign
import Draft
import PartDesignGui
import csv
import re
import numpy as np
# import scipy as sc
from scipy import interpolate
from PySide import QtGui






# Parameters
thickness = 10  # Thickness of the shell, i.e. we displace the profile "thickness" mm in the Y direction.
outfile = "out_profile.txt"



# Overall dimensions of regenerative cooling
innerwall_thickness = 3          # Thickness of material between chamber wall and the channel (y-dirction)

# Channel dimensions
channel_bottom_reduction = 10    # How far back do we want to bring the channel section in mm
channel_top_reduction  = 10      # How far forward do we want to bring the channel section in mm
channel_num_channels  = 10       # Number of channels
channel_width_top     = 3
channel_width_throat  = 2
channel_width_exit    = 3
channel_height_top    = 2
channel_height_throat = 2
channel_height_exit   = 2



# Variables
wire = []


doc = App.newDocument()

file_dialog = QtGui.QFileDialog()
rpa_file_path = file_dialog.getOpenFileName()[0]
print("\nImporting: " + rpa_file_path + "\n")


folder = os.path.dirname(rpa_file_path)
outfile_path = folder + "\\" + outfile
print("Generating new contour file: ", outfile_path)

p = re.compile('^#')
firstline = 0

points = []
num_points = 0
linenum = 0
# x, y list of points separated, so we can utilise numpy gradient
x_points = []
y_points = []
with open(outfile_path, 'w') as f:
	with open(rpa_file_path) as rpa_file:
		content = rpa_file.readlines()
		for line in content:
			if p.match(line):
				continue
			else:
				num_points = num_points + 1
				linenum = linenum + 1
				if firstline == 0:
					firstline = 1
					f.write("i    x     y" + "\n")
				# print(linenum, "     ", line.strip())
				f.write(str(linenum) + "     " + line.strip() + "\n")
				cells = line.split()
				x = cells[0]
				y = cells[1]
				x_points.append(float(x))
				y_points.append(float(y))
				points.append([x, y])

	# print("Added ", num_points, " to file")
	# Initialise function to find gradient
	curve_grad = np.gradient(y_points, x_points)

	for i in range(1, num_points+1):
		x = float(points[-i][0])
		y = float(points[-i][1])

		

		# Adding thickness to the y-direction is not what we want. The thickness is length of vector tangent to surface.
        # y = float(y) + thickness

		# While we are at it, we find out what the point is out outter wall of channel
		# First we need to find vector that is tangent to the point we are interested in.
		grad_vector = [1, curve_grad[-i]]
		grad_vector_unit = np.round(grad_vector / np.linalg.norm(grad_vector),3)
		# print(grad_vector_unit)

		# Then we want to find the vector that is orthogonal to this vector
		if grad_vector_unit[1] == 0:
			orthogonal_vector = [0, 1]
		else:
			orthogonal_vector = [1, - 1 / grad_vector_unit[1]]
			orthogonal_vector = np.round(orthogonal_vector / np.linalg.norm(orthogonal_vector), 3)

		# We want the vector always pointing up in the y-direction (there are two vectors that are perpendicular, and this is the one we want)
		if orthogonal_vector[1] < 0:
			orthogonal_vector[0] = -1 * orthogonal_vector[0]
			orthogonal_vector[1] = -1 * orthogonal_vector[1]


		# Find the new location / point.
		# v = innerwall_thickness * orthogonal_vector
		v = np.multiply(orthogonal_vector, thickness)
		new_x = x + v[0]
		new_y = y + v[1]

		linenum = linenum + 1
		# print(linenum, "     ", x, "     ", y)
		f.write(str(linenum) + "     " + str(new_x) + "     " + str(new_y) + "\n")


	#linenum = linenum + 1
	#x = points[0][0]
	#y = points[0][1]
	#f.write(str(linenum) + "     " + str(x) + "     " + str(y) + "\n")

print("Created output file: ", outfile)


# this read the csv to generate the regenerative cooling unit.
with open(outfile_path) as csv_file:
	csv_reader = csv.DictReader(csv_file, delimiter=' ', skipinitialspace=True)
	line_count = 0
	for row in csv_reader:
		# for the first row print the headers
		if line_count == 0:
			print(f'Keys are: {", ".join(row)}\n')
			line_count += 1
		# for other rows extract the information
		x = row["x"]
		y = row["y"]

		# and create the geometry
		# print(x, " ", y)
		wire.append(FreeCAD.Vector(float(x),float(y),float(0))) # append the coordinates
		line_count += 1

	print(f'\nProcessed {line_count} lines.\n')
	wire_object = Draft.makeWire(wire,closed=True,face=False,support=None)   # create the wire open


doc.recompute()

sketch_nozzle = Draft.make_sketch([wire_object], autoconstraints=True, delete=False, radiusPrecision=0)
doc.recompute()

doc.addObject('PartDesign::Body','Body')
doc.Body.Group = [sketch_nozzle]
doc.recompute()

doc.getObject('Sketch').Support = (doc.getObject('XY_Plane'), [''])
doc.getObject('Sketch').MapMode = 'FlatFace'
doc.recompute()



doc.getObject('Body').newObject('PartDesign::Revolution','Revolution')
doc.getObject('Revolution').Profile = sketch_nozzle
doc.getObject('Revolution').ReferenceAxis = (doc.getObject('X_Axis'), [''])
doc.getObject('Revolution').Angle = 360.0
doc.getObject('Revolution').Reversed = 1
doc.getObject('Sketch').Visibility = False
doc.recompute()



# this read the csv to generate the channels
# NOTE, we need to take into account the channel specs...this is to allow us to use the profile to generate 
# channels that match curvature of the nozzle profile.
# This takes 3 steps
# - load data into array  - This was done above and is in list: points
# - process array of data to conform with design settings
# - Parse


channel_points = []  # Holds points for single channel


# Get min and max X points.
for i in range(0, num_points):
	if i == 0:
		min_x = float(points[i][0])
		max_x = float(min_x)
	else:
		min_x = min(min_x, float(points[i][0]))
		max_x = max(max_x, float(points[i][0]))

    
print("Min x: ", min_x)
print("Max x: ", max_x)






# Start generating "inner" points of channel
channel_points = []           # Points closest to Combustion chamber

channel_points_raw = []       # Where we hold the points in raw format, so we can go over this to generate other points.
channel_points_raw_x = []
channel_points_raw_y = []
channel_points_outter = []    # Points furtherest from Combustion chamber
num_points2 = 0
for i in range(0, num_points-1):
	x =  float(points[i][0])
	y =  float(points[i][1])

	if i != num_points:
		next_x =  float(points[i+1][0])
		next_y =  float(points[i+1][1])
	
	
	# Make sure we don't breach top of nozzle with channel
	if x < min_x + channel_top_reduction:
		if next_x < min_x + channel_top_reduction:
			continue
		else:
			print("x, next_x = ", x, ", ", next_x)
			f = interpolate.interp1d([x, next_x], [y, next_y])
			new_x = min_x + channel_top_reduction
			new_y = f(new_x)
			# Make sure we don't breach bottom of nozzle with channel
	elif x > max_x - channel_bottom_reduction:
		if prev_x < max_x - channel_bottom_reduction:
			f = interpolate.interp1d([prev_x, x], [prev_y, y])
			new_x = max_x - channel_bottom_reduction
			new_y = f(new_x)
		else:
			continue
	else:
		new_x = x
		new_y = y



	# Add this point to the channel Wall
	# new_y = new_y + innerwall_thickness
	# channel_points.append(FreeCAD.Vector(float(new_x),float(new_y),float(0))) # append the coordinates
	# print("INNER Points: ", new_x, ", ", new_y)


	
	# While we are at it, we find out what the point is out outter wall of channel
	# First we need to find vector that is tangent to the point we are interested in.
	grad_vector = [1, curve_grad[i]]
	grad_vector_unit = np.round(grad_vector / np.linalg.norm(grad_vector),3)
	# print(grad_vector_unit)

	# Then we want to find the vector that is orthogonal to this vector
	if grad_vector_unit[1] == 0:
		orthogonal_vector = [0, 1]
	else:
		orthogonal_vector = [1, - 1 / grad_vector_unit[1]]
		orthogonal_vector = np.round(orthogonal_vector / np.linalg.norm(orthogonal_vector), 3)

	# We want the vector always pointing up in the y-direction (there are two vectors that are perpendicular, and this is the one we want)
	if orthogonal_vector[1] < 0:
		orthogonal_vector[0] = -1 * orthogonal_vector[0]
		orthogonal_vector[1] = -1 * orthogonal_vector[1]


	# Find the new location / point.
	# v = innerwall_thickness * orthogonal_vector
	v = np.multiply(orthogonal_vector, innerwall_thickness)
	new_x = new_x + v[0]
	new_y = new_y + v[1]


	# We push data on to these lists to make the step of creating the outer edge of channel a little less complex.
	channel_points_raw_x.append(float(new_x))
	channel_points_raw_y.append(float(new_y))
	channel_points_raw.append([float(new_x),float(new_y)])
	num_points2  = num_points2  + 1
	
	# now add points to List that will be used to do the drawin.g
	channel_points.append(FreeCAD.Vector(float(new_x),float(new_y),float(0))) # append the coordinates
	print("INNER Points: ", new_x, ", ", new_y)


	prev_x = x
	prev_y = y


print(channel_points_raw_x)
print(channel_points_raw_y)

curve_grad = np.gradient(channel_points_raw_y, channel_points_raw_x)


for i in range(1, num_points2 +1):
	x = float(channel_points_raw[-i][0])
	y = float(channel_points_raw[-i][1])

	# Calculate channel height at this point along
	channel_height = channel_height_top

	# Adding thickness to the y-direction is not what we want. The thickness is length of vector tangent to surface.
	# y = float(y) + thickness
	# While we are at it, we find out what the point is out outter wall of channel
	# First we need to find vector that is tangent to the point we are interested in.
	grad_vector = [1, curve_grad[-i]]
	grad_vector_unit = np.round(grad_vector / np.linalg.norm(grad_vector),3)
	# print(grad_vector_unit)

	# Then we want to find the vector that is orthogonal to this vector
	if grad_vector_unit[1] == 0:
		orthogonal_vector = [0, 1]
	else:
		orthogonal_vector = [1, - 1 / grad_vector_unit[1]]
		orthogonal_vector = np.round(orthogonal_vector / np.linalg.norm(orthogonal_vector), 3)

	# We want the vector always pointing up in the y-direction (there are two vectors that are perpendicular, and this is the one we want)
	if orthogonal_vector[1] < 0:
		orthogonal_vector[0] = -1 * orthogonal_vector[0]
		orthogonal_vector[1] = -1 * orthogonal_vector[1]


	# Find the new location / point.
	# v = innerwall_thickness * orthogonal_vector
	v = np.multiply(orthogonal_vector, channel_height)
	new_x = x + v[0]
	new_y = y + v[1]

	linenum = linenum + 1
	# print(linenum, "     ", x, "     ", y)
	# f.write(str(linenum) + "     " + str(new_x) + "     " + str(new_y) + "\n")
	channel_points.append(FreeCAD.Vector(float(new_x),float(new_y),float(0))) # append the coordinates




channel_object = Draft.makeWire(channel_points,closed=True,face=False,support=None)   # create the wire open
doc.recompute()

sketch_channel = Draft.make_sketch([channel_object], autoconstraints=True, delete=False, radiusPrecision=0)
doc.recompute()


print(f'\nProcessed {line_count} lines.\n')



