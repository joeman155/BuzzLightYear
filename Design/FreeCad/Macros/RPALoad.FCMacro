# -*- coding: utf-8 -*-
#
# Name: RPALoad.FCMacro
# Purpose: Given a RPA txt contour file and some additional values, generate the freecad file for the nozzle.
#

# Macro Begin: C:\Users\joema\OneDrive\Desktop\freecad\RPALoad.FCMacro +++++++++++++++++++++++++++++++++++++++++++++++++
import FreeCAD
import PartDesign
import Draft
import PartDesignGui
import csv
import re
import numpy as np
import math
# import scipy as sc
from scipy import interpolate
from PySide import QtGui






# Parameters
outfile = "out_profile.txt"







# Overall dimensions of regenerative cooling
regen_thickness = 10             # Total thickness of regenerative shell, i.e. we displace the profile "thickness" mm in the Y direction.
innerwall_thickness = 3          # Thickness of material between chamber wall and the channel (y-dirction)


# Channel dimensions
channel_bottom_reduction = 10    # How far back do we want to bring the channel section in mm
channel_top_reduction  = 10      # How far forward do we want to bring the channel section in mm
channel_count         = 20       # Number of channels
channel_width_top     = 3
channel_width_throat  = 2
channel_width_bottom  = 3
channel_height_top    = 2
channel_height_throat = 4
channel_height_bottom = 2

# Coolant Entry
coolant_entry_ring_height     = 10  # Height if ring, that connects all the channels
coolant_entry_torus_thickness = 3   # Thickness of torus metal manifold at coolant exit (top of motor)


# Coolant Exit
coolant_exit_ring_height    = 10    # Height if ring, that connects all the channels
coolant_exit_torus_thickness = 3    # Thickness of torus metal manifold at coolant exit (top of motor)


#
# Basic physical parameters of the component
# tvs - Thrust Vector System
# eng - Engine
# mount - part of the mount system
# p1    - p for Part  ... #1
#
# desc: Component that is attached to the engine body - conduit for TVS force to pivot engine
#
tvs_eng_mount_p1_radius    = 0     # Inner Radius - THIS IS SET LATER
tvs_eng_mount_p1_angle     = 0     # Degrees - THIS IS SET LATER
tvs_eng_mount_p1_width     = 10    # mm - nominal arc - one point to other (straight line) distance
tvs_eng_mount_p1_thickness = 3     # thickness of this component
tvs_eng_mount_p1_height    = 30    # Height of the component
tvs_eng_mount_p1_clearance = 1     # Clearance on each side of the p2 part.




#
# Basic physical parameters of the component
# tvs - Thrust Vector System
# eng - Engine
# mount - part of the mount system
# p2    - p for Part  ... #2
#
# desc: Component that TVS rod attaches to, to pivot engine.
#       We actually have two of these per pivot, several mm apart, but we ony define ONE here.
#
tvs_eng_mount_p2_radial_offset   = 0   # How far from axis this component starts - THIS IS SET LATER!
tvs_eng_mount_p2_radius1         = 10    # outer radius of component
tvs_eng_mount_p2_radius2         = 5     # inner radius (hole) in the component
tvs_eng_mount_p2_circle_distance = 10    # Distance from outer surface of p1 to center of circle
tvs_eng_mount_p2_thickness       = 3     # thickness of this component
tvs_eng_mount_p2_gap             = 5     # Gap between two of these parts at BASE (arc length)
tvs_eng_mount_p2_base_width      = tvs_eng_mount_p1_height # We want it to FIT on P1.
tvs_eng_mount_p2_base_height     = 20    # Height of the component ...RADIALLY how far above p1
tvs_eng_mount_p2_sep             = 3     # Separation between the two p2 parts.






# Variables
wire = []
channel_throat_radius = 99999       # This is radius to channel wall, closest to combustion chamber.  # Intentially set too high. Is deduced later.
channel_top_radius    = 0           # Radius of channel wall at the top of motor
channel_bottom_radius = 0           # Radius of channel wall at the bottom of motor
increment_distance = 1              # We approximate curved surfaces by breaking them down into small bits; what se specify here
overlap = 0.2                       # Because we create arcs as discrete straight lines, they won't 100% touch a surface at some points
                                    # We 


doc = App.newDocument()


# Make Groups
RegenCoolingChannels = App.ActiveDocument.addObject("App::DocumentObjectGroup", "RegenCoolingChannels")
MotorGroup = App.ActiveDocument.addObject("App::DocumentObjectGroup", "MotorGroup")




file_dialog = QtGui.QFileDialog()
rpa_file_path = file_dialog.getOpenFileName()[0]
print("\nImporting: " + rpa_file_path + "\n")


folder = os.path.dirname(rpa_file_path)
outfile_path = folder + "\\" + outfile
print("Generating new contour file: ", outfile_path)

p = re.compile('^#')
firstline = 0

points = []
num_points = 0
linenum = 0
# x, y list of points separated, so we can utilise numpy gradient
x_points = []
y_points = []
with open(outfile_path, 'w') as f:
	with open(rpa_file_path) as rpa_file:
		content = rpa_file.readlines()
		for line in content:
			if p.match(line):
				continue
			else:
				num_points = num_points + 1
				linenum = linenum + 1
				if firstline == 0:
					firstline = 1
					f.write("i    x     y" + "\n")
				# print(linenum, "     ", line.strip())
				f.write(str(linenum) + "     " + line.strip() + "\n")
				cells = line.split()
				x = cells[0]
				y = cells[1]
				x_points.append(float(x))
				y_points.append(float(y))
				points.append([x, y])

	# print("Added ", num_points, " to file")
	# Initialise function to find gradient
	curve_grad = np.gradient(y_points, x_points)

	for i in range(1, num_points+1):
		x = float(points[-i][0])
		y = float(points[-i][1])

		

		# Adding thickness to the y-direction is not what we want. The thickness is length of vector tangent to surface.
        # y = float(y) + thickness

		# While we are at it, we find out what the point is out outter wall of channel
		# First we need to find vector that is tangent to the point we are interested in.
		grad_vector = [1, curve_grad[-i]]
		grad_vector_unit = np.round(grad_vector / np.linalg.norm(grad_vector),8)
		# print(grad_vector_unit)

		# Then we want to find the vector that is orthogonal to this vector
		if grad_vector_unit[1] == 0:
			orthogonal_vector = [0, 1]
		else:
			orthogonal_vector = [1, - 1 / grad_vector_unit[1]]
			orthogonal_vector = np.round(orthogonal_vector / np.linalg.norm(orthogonal_vector), 8)

		# We want the vector always pointing up in the y-direction (there are two vectors that are perpendicular, and this is the one we want)
		if orthogonal_vector[1] < 0:
			orthogonal_vector[0] = -1 * orthogonal_vector[0]
			orthogonal_vector[1] = -1 * orthogonal_vector[1]


		# Find the new location / point.
		# v = innerwall_thickness * orthogonal_vector
		v = np.multiply(orthogonal_vector, regen_thickness)
		new_x = x + v[0]
		new_y = y + v[1]

		linenum = linenum + 1
		# print(linenum, "     ", x, "     ", y)
		f.write(str(linenum) + "     " + str(new_x) + "     " + str(new_y) + "\n")


	#linenum = linenum + 1
	#x = points[0][0]
	#y = points[0][1]
	#f.write(str(linenum) + "     " + str(x) + "     " + str(y) + "\n")

print("Created output file: ", outfile)


# this read the csv to generate the regenerative cooling unit.
with open(outfile_path) as csv_file:
	csv_reader = csv.DictReader(csv_file, delimiter=' ', skipinitialspace=True)
	line_count = 0
	for row in csv_reader:
		# for the first row print the headers
		if line_count == 0:
			print(f'Keys are: {", ".join(row)}\n')
			line_count += 1
		# for other rows extract the information
		x = row["x"]
		y = row["y"]

		# and create the geometry
		# print(x, " ", y)
		wire.append(FreeCAD.Vector(float(x),float(y),float(0))) # append the coordinates
		line_count += 1

	print(f'\nProcessed {line_count} lines.\n')
	wire_object = Draft.makeWire(wire,closed=True,face=False,support=None)   # create the wire open


doc.recompute()

sketch_nozzle = Draft.make_sketch([wire_object], autoconstraints=True, delete=False, radiusPrecision=0)
doc.recompute()

doc.addObject('PartDesign::Body','MotorBody')
doc.MotorBody.Group = [sketch_nozzle]
doc.recompute()

doc.getObject('Sketch').Support = (doc.getObject('XY_Plane'), [''])
doc.getObject('Sketch').MapMode = 'FlatFace'
doc.recompute()



doc.getObject('MotorBody').newObject('PartDesign::Revolution','Revolution')
doc.getObject('Revolution').Profile = sketch_nozzle
doc.getObject('Revolution').ReferenceAxis = (doc.getObject('X_Axis'), [''])
doc.getObject('Revolution').Angle = 360.0
doc.getObject('Revolution').Reversed = 1
doc.getObject('Sketch').Visibility = False
doc.recompute()


wire_object.Visibility = False
doc.recompute()



MotorGroup.addObjects([doc.getObject('MotorBody')])



# this read the csv to generate the channels
# NOTE, we need to take into account the channel specs...this is to allow us to use the profile to generate 
# channels that match curvature of the nozzle profile.
# This takes 3 steps
# - load data into array  - This was done above and is in list: points
# - process array of data to conform with design settings
# - Parse


channel_points = []  # Holds points for single channel


# Get min and max X points.
chamber_length = 0
for i in range(0, num_points):
	x = float(points[i][0])
	y = float(points[i][1])
	if i == 0:
		min_x = float(points[i][0])
		max_x = float(min_x)
		prev_x = x
		prev_y = y
		continue
	else:
		min_x = min(min_x, float(points[i][0]))
		max_x = max(max_x, float(points[i][0]))

	if y != prev_y and chamber_length == 0:
		chamber_length = prev_x

	prev_x = x
	prev_y = y
    
print("Min x: ", min_x)
print("Max x: ", max_x)
print("chamber_length: ", chamber_length)





# Start generating "inner" points of channel
channel_points = []           # Points closest to Combustion chamber

channel_points_raw = []       # Where we hold the points in raw format, so we can go over this to generate other points.
channel_points_raw_x = []
channel_points_raw_y = []
channel_points_outter = []    # Points furtherest from Combustion chamber
num_points_channel = 0
for i in range(0, num_points-1):
	x =  float(points[i][0])
	y =  float(points[i][1])

	if i != num_points:
		next_x =  float(points[i+1][0])
		next_y =  float(points[i+1][1])
	
	
	# Make sure we don't breach top of nozzle with channel
	if x < min_x + channel_top_reduction:
		if next_x < min_x + channel_top_reduction:
			continue
		else:
			f = interpolate.interp1d([x, next_x], [y, next_y])
			new_x = min_x + channel_top_reduction
			new_y = f(new_x)
			# Make sure we don't breach bottom of nozzle with channel
	elif x > max_x - channel_bottom_reduction:
		if prev_x < max_x - channel_bottom_reduction:
			f = interpolate.interp1d([prev_x, x], [prev_y, y])
			new_x = max_x - channel_bottom_reduction
			new_y = f(new_x)
		else:
			continue
	else:
		new_x = x
		new_y = y



	# Add this point to the channel Wall
	# new_y = new_y + innerwall_thickness
	# channel_points.append(FreeCAD.Vector(float(new_x),float(new_y),float(0))) # append the coordinates
	# print("INNER Points: ", new_x, ", ", new_y)


	
	# While we are at it, we find out what the point is out outter wall of channel
	# First we need to find vector that is tangent to the point we are interested in.
	grad_vector = [1, curve_grad[i]]
	grad_vector_unit = np.round(grad_vector / np.linalg.norm(grad_vector),8)

	# Then we want to find the vector that is orthogonal to this vector
	if grad_vector_unit[1] == 0:
		orthogonal_vector = [0, 1]
	else:
		orthogonal_vector = [1, - 1 / grad_vector_unit[1]]
		orthogonal_vector = np.round(orthogonal_vector / np.linalg.norm(orthogonal_vector), 8)

	# We want the vector always pointing up in the y-direction (there are two vectors that are perpendicular, and this is the one we want)
	if orthogonal_vector[1] < 0:
		orthogonal_vector[0] = -1 * orthogonal_vector[0]
		orthogonal_vector[1] = -1 * orthogonal_vector[1]


	# Find the new location / point.
	# v = innerwall_thickness * orthogonal_vector
	v = np.multiply(orthogonal_vector, innerwall_thickness)
	new_x = new_x + v[0]
	new_y = new_y + v[1]


	# We push data on to these lists to make the step of creating the outer edge of channel a little less complex.
	channel_points_raw_x.append(float(new_x))
	channel_points_raw_y.append(float(new_y))
	channel_points_raw.append([float(new_x),float(new_y)])
	channel_throat_radius = min(channel_throat_radius, float(new_y))
	num_points_channel  = num_points_channel  + 1
	
	# now add points to List that will be used to do the drawin.g
	channel_points.append(FreeCAD.Vector(float(new_x),float(new_y),float(0))) # append the coordinates


	prev_x = x
	prev_y = y

# Get radius of channel at top and bottom. Required later for calculating the height of channel
channel_bottom_radius = channel_points_raw_y[0]
channel_top_radius    = channel_points_raw_y[len(channel_points_raw_y)-1]


# Start generating "outer" points of channel
channel_outer_points_raw = []
curve_grad = np.gradient(channel_points_raw_y, channel_points_raw_x)
location   = 2    # 2 is for below throat, near exist   #1 is for above throat
for i in range(1, num_points_channel +1):
	x = float(channel_points_raw[-i][0])
	y = float(channel_points_raw[-i][1])

	# Work out if are moving from the bottom of nozzle to top of nozzle (combustion chamber)
	if prev_y  < y:
		location = 1

	if location == 2:
		r = (y - channel_throat_radius)/(channel_bottom_radius - channel_throat_radius)
		channel_height = channel_height_bottom * r  +  channel_height_throat * (1 - r)
	elif location == 1:
		r = (y - channel_throat_radius)/(channel_top_radius - channel_throat_radius)
		channel_height = channel_height_top * r  +  channel_height_throat * (1 - r)
	else:
		print("ERROR. UNEXPECTED LOCATION: ", location)


	# Calculate channel height at this point along
	# channel_height = channel_height_top

	# Adding thickness to the y-direction is not what we want. The thickness is length of vector tangent to surface.
	# y = float(y) + thickness
	# While we are at it, we find out what the point is out outter wall of channel
	# First we need to find vector that is tangent to the point we are interested in.
	grad_vector = [1, curve_grad[-i]]
	grad_vector_unit = np.round(grad_vector / np.linalg.norm(grad_vector),8)
	# print(grad_vector_unit)

	# Then we want to find the vector that is orthogonal to this vector
	if grad_vector_unit[1] == 0:
		orthogonal_vector = [0, 1]
	else:
		orthogonal_vector = [1, - 1 / grad_vector_unit[1]]
		orthogonal_vector = np.round(orthogonal_vector / np.linalg.norm(orthogonal_vector), 8)

	# We want the vector always pointing up in the y-direction (there are two vectors that are perpendicular, and this is the one we want)
	if orthogonal_vector[1] < 0:
		orthogonal_vector[0] = -1 * orthogonal_vector[0]
		orthogonal_vector[1] = -1 * orthogonal_vector[1]


	# Find the new location / point.
	# v = innerwall_thickness * orthogonal_vector
	v = np.multiply(orthogonal_vector, channel_height)
	new_x = x + v[0]
	new_y = y + v[1]

	linenum = linenum + 1
	# print(linenum, "     ", x, "     ", y)
	# f.write(str(linenum) + "     " + str(new_x) + "     " + str(new_y) + "\n")
	channel_points.append(FreeCAD.Vector(float(new_x),float(new_y),float(0))) # append the coordinates
	channel_outer_points_raw.append([float(new_x),float(new_y)])

	prev_x = x
	prev_y = y


channel_object = Draft.makeWire(channel_points,closed=True,face=False,support=None)   # create the wire open
doc.recompute()

sketch_channel = Draft.make_sketch([channel_object], autoconstraints=True, delete=False, radiusPrecision=0)
doc.recompute()


print(f'\nProcessed {line_count} lines.\n')

# Calculate angle we must revolve the sketch to ensure we get the channel width desired.
top_radius = float(y_points[0]) + innerwall_thickness
combustion_chamber_internal_radius = y_points[0]
circumference = 2 * np.pi * top_radius
angle_rotation = 360 * channel_width_top / circumference

print("Radius: ", top_radius)
print("Circumference: ", circumference)
print("ar: ", angle_rotation)


# Create the 3-d representation of the channel
doc.addObject('PartDesign::Body','BodyChannel')
doc.BodyChannel.Group = [sketch_channel]
doc.recompute()

sketch_channel.Support = (doc.getObject('XY_Plane'), [''])
sketch_channel.MapMode = 'FlatFace'
doc.recompute()



doc.getObject('BodyChannel').newObject('PartDesign::Revolution','RevolutionChannel')
doc.getObject('RevolutionChannel').Profile = sketch_channel
doc.getObject('RevolutionChannel').ReferenceAxis = (doc.getObject('X_Axis'), [''])
doc.getObject('RevolutionChannel').Angle = angle_rotation
doc.getObject('RevolutionChannel').Reversed = 1
sketch_channel.Visibility = False
doc.recompute()



channel_object.Visibility = False
doc.recompute()




# Make channel_count copies and rotate these.
RegenCoolingChannels.addObjects([doc.getObject('BodyChannel')])
for i in range(1,channel_count):
	channel_copy = doc.copyObject(doc.getObject('BodyChannel'), True)
	angle = (360 / channel_count) * i
	channel_copy.Placement=App.Placement(App.Vector(0,0,0), App.Rotation(App.Vector(1,0,0),angle), App.Vector(0,0,0))
	RegenCoolingChannels.addObjects([channel_copy])



# Add the coolant exit
doc.addObject("Part::Cylinder","Cylinder_1")
doc.ActiveObject.Label = "Cylinder_coolant_exit_build1"
doc.recompute()
doc.getObject('Cylinder_1').Radius = top_radius
doc.getObject('Cylinder_1').Height = coolant_exit_ring_height


doc.addObject("Part::Cylinder","Cylinder_2")
doc.ActiveObject.Label = "Cylinder_coolant_exit_build2"
doc.recompute()
doc.getObject('Cylinder_2').Radius = top_radius + channel_height_top
doc.getObject('Cylinder_2').Height = coolant_exit_ring_height

doc.addObject("Part::Cut","Coolant_exit_ring")
doc.Coolant_exit_ring.Base = doc.Cylinder_2
doc.Coolant_exit_ring.Tool = doc.Cylinder_1
doc.recompute()



# Next we rotate and move this into place
displacement = coolant_exit_ring_height + channel_top_reduction
angle_rotation = -90
# doc.Coolant_exit_ring.Placement=App.Placement(App.Vector(0,0,0), App.Rotation(App.Vector(0,1,0),-90), App.Vector(0,0,0))
doc.Coolant_exit_ring.Placement=App.Placement(App.Vector(displacement,0,0), App.Rotation(App.Vector(0,1,0),angle_rotation), App.Vector(0,0,0))

RegenCoolingChannels.addObjects([doc.getObject('Coolant_exit_ring')])




########################################################################
# Add the coolant entry ring
# We use the channel data at exit and work "back". Because the angle of the exit is normally small
# we use the x-displacement, not the curved length as the height of ring
#
# This is the INNER part of the coolant exit ring. (part 1 of 3)
coolant_exit_ring_points = []
for i in range(1, num_points_channel +1):
	x = float(channel_points_raw[-i][0])
	y = float(channel_points_raw[-i][1])
	
	if i == 1:
		x_start = x

	if x_start - x > coolant_entry_ring_height:
		f = interpolate.interp1d([prev_x, x], [prev_y, y])
		xx = x_start - coolant_entry_ring_height
		yy = f(xx)
		coolant_exit_ring_points.append([xx, yy])
		break
	else:
		xx = x
		yy = y

	coolant_exit_ring_points.append([xx, yy])
	# print("added xx, yy: ", xx, ", ", yy)



	prev_x = x
	prev_y = y


# Reverse list, so we can continue to add points in
coolant_exit_ring_points.reverse()



# This is the OUTER part of the coolant exit ring. (part 2 of 3)
for i in range(0, num_points_channel):
	x = float(channel_outer_points_raw[i][0])
	y = float(channel_outer_points_raw[i][1])
	
	if i == 0:
		x_start = x

	if x_start - x > coolant_entry_ring_height:
		f = interpolate.interp1d([prev_x, x], [prev_y, y])
		xx = x_start - coolant_entry_ring_height
		yy = f(xx)
		coolant_exit_ring_points.append([xx, yy])
		break
	else:
		xx = x
		yy = y

	coolant_exit_ring_points.append([xx, yy])
	# print("added xx, yy: ", xx, ", ", yy)

	prev_x = x
	prev_y = y


# print(coolant_exit_ring_points)


# Now that we have Inner and Outer points, we create a sketch.
coolant_entry_ring = []
for i in range(1, len(coolant_exit_ring_points)):
	x = coolant_exit_ring_points[i][0]
	y = coolant_exit_ring_points[i][1]
	coolant_entry_ring.append(FreeCAD.Vector(x,y,float(0))) # append the coordinates


coolant_entry_ring_object = Draft.makeWire(coolant_entry_ring,closed=True,face=False,support=None)   # create the wire open
doc.recompute()

sketch_coolant_entry_ring = Draft.make_sketch([coolant_entry_ring_object], autoconstraints=True, delete=False, radiusPrecision=0)
doc.recompute()


# Revolve sketch to finish off coolant entry ring
doc.addObject('PartDesign::Body','Coolant_entry_ring_body')
doc.Coolant_entry_ring_body.Group = [sketch_coolant_entry_ring]

sketch_coolant_entry_ring.Support = (doc.getObject('XY_Plane040'), [''])
sketch_coolant_entry_ring.MapMode = 'FlatFace'
doc.recompute()

doc.getObject('Coolant_entry_ring_body').newObject('PartDesign::Revolution','Coolant_entry_ring_revolution')
doc.getObject('Coolant_entry_ring_revolution').Profile = sketch_coolant_entry_ring
# doc.getObject('Coolant_entry_ring_revolution').ReferenceAxis = (doc.getObject('X_Axis040'), [''])
doc.getObject('Coolant_entry_ring_revolution').ReferenceAxis = (doc.getObject('X_Axis'), [''])
doc.getObject('Coolant_entry_ring_revolution').Angle = 360.000000
doc.getObject('Coolant_entry_ring_revolution').Midplane = 0
doc.getObject('Coolant_entry_ring_revolution').Reversed = 0
doc.recompute()

sketch_coolant_entry_ring.Visibility = False
doc.recompute()

coolant_entry_ring_object.Visibility = False
doc.recompute()


# Add to Regen Cooling components
RegenCoolingChannels.addObjects([doc.getObject('Coolant_entry_ring_body')])
doc.recompute()






######################################################################
# Half-Torus - Coolant cooling exit
doc.addObject("Part::Torus","Coolant_exit_Torus")
doc.ActiveObject.Label = "Coolant_exit_Torus"


doc.getObject('Coolant_exit_Torus').Radius1 = top_radius + channel_height_top
doc.getObject('Coolant_exit_Torus').Radius2 = coolant_exit_ring_height / 2
doc.getObject('Coolant_exit_Torus').Angle1 = '-90.00 deg'
doc.getObject('Coolant_exit_Torus').Angle2 = '90.00 deg'

displacement = channel_top_reduction + coolant_exit_ring_height / 2
angle_rotation = -90
doc.getObject('Coolant_exit_Torus').Placement=App.Placement(App.Vector(displacement,0,0), App.Rotation(App.Vector(0,1,0),angle_rotation), App.Vector(0,0,0))
doc.recompute()


# Add to Regen Cooling components
RegenCoolingChannels.addObjects([doc.getObject('Coolant_exit_Torus')])
doc.recompute()





######################################################################
# Coolant Entry 1/2 "torus shaped" object
# This is the 1/2 torus cavity that bounds the coolant entry ring.
coolant_entry_torus_points = []
for i in range(0, num_points_channel):
	x = float(channel_outer_points_raw[i][0])
	y = float(channel_outer_points_raw[i][1])
	
	if i == 0:
		x_start = x
		min_x = x
		max_x = x
		min_y = y
		max_y = y

	if x_start - x > coolant_entry_ring_height:
		f = interpolate.interp1d([prev_x, x], [prev_y, y])
		xx = x_start - coolant_entry_ring_height
		yy = f(xx)
		coolant_entry_torus_points.append([xx, yy])
		min_x = min(min_x, xx)
		max_x = max(max_x, xx)
		min_y = min(min_y, yy)
		max_y = max(max_y, yy)
		break
	else:
		xx = x
		yy = y

	min_x = min(min_x, xx)
	max_x = max(max_x, xx)
	min_y = min(min_y, yy)
	max_y = max(max_y, yy)
	coolant_entry_torus_points.append([xx, yy])
	# print("added xx, yy: ", xx, ", ", yy)

	prev_x = x
	prev_y = y


# Now we find "mid-point" between (min_x, min_y) and (max_x, max_y)
f = interpolate.interp1d([min_x, max_x], [min_y, max_y])
middle_x = (min_x + max_x) / 2
middle_y = f(middle_x)
gradient_angle = math.atan((max_y - min_y) / (max_x - min_x)) * 180 / np.pi

print("middle_x, middle_y: ", middle_x, ", ", middle_y)
print("Angle of strip: ", gradient_angle)


coolant_entry_torus_points.reverse()

# Now we create approximation of a circule ( 5 degrees apart ) to make the "torus" like cavity at coolant entry.
step_size = 5   # number of degrees
# for i in range(step_size - gradient_angle, 180 - (step_size - gradient_angle), step_size):
positions = int(180 / step_size)
for i in range(1, positions - 1):
	angle = (i * step_size + gradient_angle) * (np.pi / 180)
	# print("i, Angle: " , i, ", ", angle)
	xx = middle_x + (coolant_entry_ring_height / 2) * math.cos(angle)
	yy = middle_y + (coolant_entry_ring_height / 2) * math.sin(angle)
	coolant_entry_torus_points.append([xx, yy])


# Now that we have Inner and Outer points, we create a sketch.
coolant_entry_torus = []
for i in range(0, len(coolant_entry_torus_points)):
	x = coolant_entry_torus_points[i][0]
	y = coolant_entry_torus_points[i][1]
	coolant_entry_torus.append(FreeCAD.Vector(x,y,float(0))) # append the coordinates


coolant_entry_torus_object = Draft.makeWire(coolant_entry_torus,closed=True,face=False,support=None)   # create the wire open
doc.recompute()

sketch_coolant_entry_torus = Draft.make_sketch([coolant_entry_torus_object], autoconstraints=True, delete=False, radiusPrecision=0)
doc.recompute()


# Revolve coolant entry torus sketch to finish off coolant entry ring
doc.addObject('PartDesign::Body','Coolant_entry_torus_body')
doc.Coolant_entry_torus_body.Group = [sketch_coolant_entry_torus]

sketch_coolant_entry_torus.Support = (doc.getObject('XY_Plane041'), [''])
sketch_coolant_entry_torus.MapMode = 'FlatFace'
doc.recompute()

doc.getObject('Coolant_entry_torus_body').newObject('PartDesign::Revolution','Coolant_entry_torus_revolution')
doc.getObject('Coolant_entry_torus_revolution').Profile = sketch_coolant_entry_torus
# doc.getObject('Coolant_entry_torus_revolution').ReferenceAxis = (doc.getObject('X_Axis041'), [''])
doc.getObject('Coolant_entry_torus_revolution').ReferenceAxis = (doc.getObject('X_Axis'), [''])
doc.getObject('Coolant_entry_torus_revolution').Angle = 360.000000
doc.getObject('Coolant_entry_torus_revolution').Midplane = 0
doc.getObject('Coolant_entry_torus_revolution').Reversed = 0
doc.recompute()

sketch_coolant_entry_torus.Visibility = False
doc.recompute()

coolant_entry_torus_object.Visibility = False
doc.recompute()


# Add to Regen Cooling components
RegenCoolingChannels.addObjects([doc.getObject('Coolant_entry_torus_body')])
doc.recompute()







######################################################################
# Create Coolant Exit OUTSIDE Torus (Top of the motor)
# Half-Torus - Coolant cooling exit
doc.addObject("Part::Torus","Coolant_outside_exit_Torus")
doc.ActiveObject.Label = "Coolant_outside_exit_Torus"


doc.getObject('Coolant_outside_exit_Torus').Radius1 = top_radius + channel_height_top
doc.getObject('Coolant_outside_exit_Torus').Radius2 = coolant_exit_torus_thickness + coolant_exit_ring_height / 2
doc.getObject('Coolant_outside_exit_Torus').Angle1 = '-90.00 deg'
doc.getObject('Coolant_outside_exit_Torus').Angle2 = '90.00 deg'

displacement = channel_top_reduction + coolant_exit_ring_height / 2
angle_rotation = -90
doc.getObject('Coolant_outside_exit_Torus').Placement=App.Placement(App.Vector(displacement,0,0), App.Rotation(App.Vector(0,1,0),angle_rotation), App.Vector(0,0,0))
doc.recompute()


# Add to Regen Cooling components
MotorGroup.addObjects([doc.getObject('Coolant_outside_exit_Torus')])
doc.recompute()







######################################################################
# Create 1/2 "torus shaped" manifold that surrounds "torus shaped" cavity at Coolant entry point. (bottom of rocket motor)
coolant_outside_entry_torus_points = []
for i in range(0, num_points_channel):
	x = float(channel_outer_points_raw[i][0])
	y = float(channel_outer_points_raw[i][1])
	
	if i == 0:
		x_start = x
		min_x = x
		max_x = x
		min_y = y
		max_y = y

	if x_start - x > coolant_entry_ring_height:
		f = interpolate.interp1d([prev_x, x], [prev_y, y])
		xx = x_start - coolant_entry_ring_height
		yy = f(xx)
		coolant_outside_entry_torus_points.append([xx, yy])
		min_x = min(min_x, xx)
		max_x = max(max_x, xx)
		min_y = min(min_y, yy)
		max_y = max(max_y, yy)
		break
	else:
		xx = x
		yy = y

	min_x = min(min_x, xx)
	max_x = max(max_x, xx)
	min_y = min(min_y, yy)
	max_y = max(max_y, yy)
	coolant_outside_entry_torus_points.append([xx, yy])
	# print("added xx, yy: ", xx, ", ", yy)

	prev_x = x
	prev_y = y


# Now we find "mid-point" between (min_x, min_y) and (max_x, max_y)
f = interpolate.interp1d([min_x, max_x], [min_y, max_y])
middle_x = (min_x + max_x) / 2
middle_y = f(middle_x)
gradient_angle = math.atan((max_y - min_y) / (max_x - min_x)) * 180 / np.pi

print("middle_x, middle_y: ", middle_x, ", ", middle_y)
print("Angle of strip: ", gradient_angle)


coolant_outside_entry_torus_points.reverse()

# Now we create approximation of a circule ( 5 degrees apart ) to make the "torus" like cavity at coolant entry.
step_size = 5   # number of degrees
# for i in range(step_size - gradient_angle, 180 - (step_size - gradient_angle), step_size):
positions = int(180 / step_size)
for i in range(0, positions+1):
	angle = (i * step_size + gradient_angle) * (np.pi / 180)
	# print("iii, Angle: " , i, ", ", angle)
	xx = middle_x + (coolant_entry_torus_thickness + coolant_entry_ring_height / 2) * math.cos(angle)
	yy = middle_y + (coolant_entry_torus_thickness + coolant_entry_ring_height / 2) * math.sin(angle)
	coolant_outside_entry_torus_points.append([xx, yy])


# Now that we have all points that make up 1/2 semi-torus, we create a sketch.
coolant_outside_entry_torus = []
for i in range(0, len(coolant_outside_entry_torus_points)):
	x = coolant_outside_entry_torus_points[i][0]
	y = coolant_outside_entry_torus_points[i][1]
	coolant_outside_entry_torus.append(FreeCAD.Vector(x,y,float(0))) # append the coordinates


coolant_outside_entry_torus_object = Draft.makeWire(coolant_outside_entry_torus,closed=True,face=False,support=None)   # create the wire open
doc.recompute()

sketch_coolant_outside_entry_torus = Draft.make_sketch([coolant_outside_entry_torus_object], autoconstraints=True, delete=False, radiusPrecision=0)
doc.recompute()


# Revolve coolant entry torus sketch to finish off coolant entry ring
doc.addObject('PartDesign::Body','Coolant_outside_entry_torus_body')
doc.Coolant_outside_entry_torus_body.Group = [sketch_coolant_outside_entry_torus]

sketch_coolant_outside_entry_torus.Support = (doc.getObject('XY_Plane042'), [''])
sketch_coolant_outside_entry_torus.MapMode = 'FlatFace'
doc.recompute()

doc.getObject('Coolant_outside_entry_torus_body').newObject('PartDesign::Revolution','Coolant_outside_entry_torus_revolution')
doc.getObject('Coolant_outside_entry_torus_revolution').Profile = sketch_coolant_outside_entry_torus
#doc.getObject('Coolant_outside_entry_torus_revolution').ReferenceAxis = (doc.getObject('X_Axis042'), [''])
doc.getObject('Coolant_outside_entry_torus_revolution').ReferenceAxis = (doc.getObject('X_Axis'), [''])
doc.getObject('Coolant_outside_entry_torus_revolution').Angle = 360.000000
doc.getObject('Coolant_outside_entry_torus_revolution').Midplane = 0
doc.getObject('Coolant_outside_entry_torus_revolution').Reversed = 0
doc.recompute()

sketch_coolant_outside_entry_torus.Visibility = False
doc.recompute()

coolant_outside_entry_torus_object.Visibility = False
doc.recompute()


# Add to Regen Cooling components
MotorGroup.addObjects([doc.getObject('Coolant_outside_entry_torus_body')])
doc.recompute()







# --------------------------------------------------------
# Create Wire of TVS Engine Mount P1 component
# This part is created as if looking axially along the rocket engines
# --------------------------------------------------------
# We visualise what this will look like
#
#           .  . 
#        .  .  .   .  
#     .   .      .   .
#      .           .   
#                      
#                       
# ........................#
#

points = []
tvs_eng_mount_p1_radius = combustion_chamber_internal_radius + regen_thickness - overlap # Outside of combustion chamber, where p1 mates to ending

# Based on separation of plates, thickness and clearance, work out angle to sweep.
tvs_eng_mount_p1_width = tvs_eng_mount_p1_thickness * 2 + tvs_eng_mount_p2_gap + tvs_eng_mount_p1_clearance * 2
tvs_eng_mount_p1_angle = math.acos(-(tvs_eng_mount_p1_width ** 2 - tvs_eng_mount_p1_radius ** 2 - tvs_eng_mount_p1_radius ** 2)/(2 * tvs_eng_mount_p1_radius * tvs_eng_mount_p1_radius)) * 180 / np.pi

# Starting point
x = 0
y = tvs_eng_mount_p1_radius
points.append([x, y])



# Form indie part of the component
segment_length = 2 * np.pi * tvs_eng_mount_p1_radius * tvs_eng_mount_p1_angle / 360
segment_count = int(np.floor(segment_length / increment_distance))
angle = segment_count / (segment_length / increment_distance) * tvs_eng_mount_p1_angle
for i in range(1,segment_count):
	theta = (i / segment_count) * angle * (np.pi / 180)
	x = tvs_eng_mount_p1_radius * np.sin(theta)
	y = tvs_eng_mount_p1_radius * np.cos(theta)
	points.append([x, y])


# Add the last point on the circular segment
x = tvs_eng_mount_p1_radius * np.sin(tvs_eng_mount_p1_angle * (np.pi / 180))
y = tvs_eng_mount_p1_radius * np.cos(tvs_eng_mount_p1_angle * (np.pi / 180))
points.append([x,y])


# Go out by "thickness" amount
v_orth = [np.sin(tvs_eng_mount_p1_angle * (np.pi / 180)), np.cos(tvs_eng_mount_p1_angle * (np.pi / 180))]
x = x + tvs_eng_mount_p1_thickness * np.sin(tvs_eng_mount_p1_angle * (np.pi / 180))
y = y + tvs_eng_mount_p1_thickness * np.cos(tvs_eng_mount_p1_angle * (np.pi / 180))
points.append([x,y])



# Now we need to the 'circle" bit back
x_start = x
y_start = y


r = tvs_eng_mount_p1_radius + tvs_eng_mount_p1_thickness
segment_length = 2 * np.pi * r * tvs_eng_mount_p1_angle / 360
segment_count = int(np.floor(segment_length / increment_distance))
angle = segment_count / (segment_length / increment_distance) * tvs_eng_mount_p1_angle * (np.pi / 180)
for i in range(1,segment_count):
	theta = (i / segment_count) * tvs_eng_mount_p1_angle * (np.pi / 180)
	x = r * np.sin(angle - theta)
	y = r * np.cos(angle - theta)
	points.append([x, y])


# Add the last point on the circular segment
phi = 0
x = r * np.sin(phi * (np.pi / 180))
y = r * np.cos(phi * (np.pi / 180))
points.append([x,y])



# Finishing point
x = 0
y = tvs_eng_mount_p1_radius
points.append([x, y])




# ---------------------------------------------------------------
# Create the other component, p2 of the TVS  This radially attaches to p1 component.
# This part is created if looking from side of engine (not radially, not axially)
# 
# We only define ONE of these and we pad, rotate, etc later on.
# ---------------------------------------------------------------
points2 = []

# We visualise what this will look like
#
#           .  . 
#        .        .  
#     .      .       .
#    .      . .        .
#   .        .          .
#  .                    .
# ........................#
#
# i.e. straight edges at an angle, arc (part of a circle) top
# straight edges intersect at tanget with arc
# Whole shape is symetrical about y axis
# The is a hole...and this hole is a certain distance from top (i.e. thickness of material)
#


# We need to do a bit geometry stuff before we get points
# theta = angle which the straight line makes with the horizontal
# line_radius = length (radius) of the large straight edge makes, where it links to the Arc

# Calcualte angle of sides wrt vertical
width = tvs_eng_mount_p2_base_width / 2
t1 = tvs_eng_mount_p2_radius1 / np.sqrt(width ** 2 + tvs_eng_mount_p2_base_height ** 2 - tvs_eng_mount_p2_radius1 **2 )
# t2 = - width / tvs_eng_mount_p2_base_height
t2 = -tvs_eng_mount_p2_base_height / width
theta = math.atan(t1) - math.atan(t2)


# Calculate length of side
print("width: ", width)
print("height: ",tvs_eng_mount_p2_base_height) 
print("tvs_eng_mount_p2_radius1: ", tvs_eng_mount_p2_radius1)
print("math.sin(theta): ", np.sin(theta))
print("math.cos(theta): ", np.cos(theta))

bigR = (width - tvs_eng_mount_p2_radius1 * np.sin(theta)) / np.cos(theta)

print("Theta, bigR : ", theta, bigR)


# Set the starting distance from the central axis of engine
tvs_eng_mount_p2_radial_offset = tvs_eng_mount_p1_radius + tvs_eng_mount_p1_thickness - overlap

# Create points
x = 0
y = 0 + tvs_eng_mount_p2_radial_offset
print("1xx, yy: ", x, y)
points2.append([x,y])


# Next point is some distance axially, the full width of the component.
x = x - tvs_eng_mount_p2_base_width
y = y + 00000000
print("2xx, yy: ", x, y)
points2.append([x,y])


# Next point is the straight edge, radially away and further axially to the center of the object
x = x + bigR * np.cos(theta)
y = y + bigR * np.sin(theta)
print("3xx, yy: ", x, y)
points2.append([x,y])



# Do the "arc"
r = tvs_eng_mount_p2_radius1
arc_angle = 2 * theta
segment_length = r * arc_angle 
segment_count = int(np.floor(segment_length / increment_distance))
angle = -segment_count / (segment_length / increment_distance) * arc_angle / 2
for i in range(1,segment_count):
	phi = (i / segment_count) * arc_angle
	x = -width + r * np.sin(angle + phi)
	y = tvs_eng_mount_p2_radial_offset + tvs_eng_mount_p2_base_height + r * np.cos(angle + phi)
	print("4xx, yy: ", x, y)
	points2.append([x, y])


# Add the last point on the circular segment
phi = arc_angle / 2
x = -width + r * np.sin(phi)
y = tvs_eng_mount_p2_radial_offset + tvs_eng_mount_p2_base_height + r * np.cos(phi)
print("5xx, yy: ", x, y)
points2.append([x,y])



# Back down to beginning
x = 0
y = tvs_eng_mount_p2_radial_offset
print("6xx, yy: ", x, y)
points2.append([x,y])


# Generate circlular hole.
points3 = []
hole_x = -width
hole_y = tvs_eng_mount_p2_radial_offset + tvs_eng_mount_p2_base_height
r = tvs_eng_mount_p2_radius2
arc_angle = 2 * np.pi
segment_length = r * arc_angle 
segment_count = int(np.floor(segment_length / increment_distance))
for i in range(1,segment_count):
	phi = (i / segment_count) * arc_angle
	x = hole_x + r * np.sin(phi)
	y = hole_y + r * np.cos(phi)
	points3.append([x, y])



# Add the last point on the circular segment
phi = arc_angle
x = hole_x + r * np.sin(phi)
y = hole_y + r * np.cos(phi)
points3.append([x,y])


# --------------------------------------------------
# DRAW COMPONENT - P1
# --------------------------------------------------

# Now that we have all points that make up these two sketches, we create the freeCad objects
tvs_eng_mount_p1_points = []
for i in range(0, len(points)):
	x = points[i][0]
	y = points[i][1]
	tvs_eng_mount_p1_points.append(FreeCAD.Vector(float(0),y,x)) # append the coordinates


tvs_eng_mount_p1_object = Draft.makeWire(tvs_eng_mount_p1_points,closed=False,face=False,support=None)   # create the wire open
doc.recompute()

sketch_tvs_eng_mount_p1 = Draft.make_sketch([tvs_eng_mount_p1_object], autoconstraints=True, delete=False, radiusPrecision=0)
doc.recompute()


# Pad p1 component
doc.addObject('PartDesign::Body','tvs_eng_mount_p1_body')
doc.tvs_eng_mount_p1_body.Group = [sketch_tvs_eng_mount_p1]

sketch_tvs_eng_mount_p1.Support = (doc.getObject('XY_Plane043'), [''])
sketch_tvs_eng_mount_p1.MapMode = 'FlatFace'
doc.recompute()

doc.getObject('tvs_eng_mount_p1_body').newObject('PartDesign::Pad','tvs_eng_mount_p1_pad')
doc.getObject('tvs_eng_mount_p1_pad').Profile = sketch_tvs_eng_mount_p1
doc.getObject('tvs_eng_mount_p1_pad').ReferenceAxis = (sketch_tvs_eng_mount_p1, ['N_Axis'])
doc.getObject('tvs_eng_mount_p1_pad').Direction = (0, 0, 1)
doc.getObject('tvs_eng_mount_p1_pad').Midplane = 0
doc.getObject('tvs_eng_mount_p1_pad').Reversed = 0
doc.getObject('tvs_eng_mount_p1_pad').Offset = 0
doc.getObject('tvs_eng_mount_p1_pad').Type = 0
doc.getObject('tvs_eng_mount_p1_pad').Length = tvs_eng_mount_p1_height
doc.getObject('tvs_eng_mount_p1_pad').TaperAngle = 0
doc.getObject('tvs_eng_mount_p1_pad').UseCustomVector = 0
doc.getObject('tvs_eng_mount_p1_pad').AlongSketchNormal = 1
doc.getObject('tvs_eng_mount_p1_pad').UpToFace = None
doc.recompute()

sketch_tvs_eng_mount_p1.Visibility = False
doc.recompute()

tvs_eng_mount_p1_object.Visibility = False
doc.recompute()


# Move/Rotate p1 into place.
x_displacement = chamber_length - tvs_eng_mount_p1_height
doc.tvs_eng_mount_p1_body.Placement=App.Placement(App.Vector(x_displacement,0,0), App.Rotation(App.Vector(0,1,0),90), App.Vector(0,0,0))
doc.recompute()

rotation_angle = tvs_eng_mount_p1_angle / 2
doc.tvs_eng_mount_p1_body.Placement=App.Placement(App.Vector(0,0,0), App.Rotation(App.Vector(1,0,0),rotation_angle), App.Vector(0,0,0)).multiply(doc.tvs_eng_mount_p1_body.Placement)



# --------------------------------------------------
# DRAW COMPONENT - P2
# --------------------------------------------------

# Now that we have all points that make up these two sketches, we create the freeCad objects
tvs_eng_mount_p2_points = []
for i in range(0, len(points2)):
	x = points2[i][0]
	y = points2[i][1]
	tvs_eng_mount_p2_points.append(FreeCAD.Vector(x,y,float(0))) # append the coordinates


tvs_eng_mount_p2_object1 = Draft.makeWire(tvs_eng_mount_p2_points,closed=False,face=False,support=None)   # create the wire open
doc.recompute()

tvs_eng_mount_p2_points = []
for i in range(0, len(points3)):
	x = points3[i][0]
	y = points3[i][1]
	tvs_eng_mount_p2_points.append(FreeCAD.Vector(x,y,float(0))) # append the coordinates


tvs_eng_mount_p2_object2 = Draft.makeWire(tvs_eng_mount_p2_points,closed=True,face=False,support=None)   # create the wire open
doc.recompute()

sketch_tvs_eng_mount_p2 = Draft.make_sketch([tvs_eng_mount_p2_object1, tvs_eng_mount_p2_object2], autoconstraints=True, delete=False, radiusPrecision=0)
doc.recompute()


# Pad p2 component
doc.addObject('PartDesign::Body','tvs_eng_mount_p2_body')
doc.tvs_eng_mount_p2_body.Group = [sketch_tvs_eng_mount_p2]

sketch_tvs_eng_mount_p2.Support = (doc.getObject('XY_Plane043'), [''])
sketch_tvs_eng_mount_p2.MapMode = 'FlatFace'
doc.recompute()

doc.getObject('tvs_eng_mount_p2_body').newObject('PartDesign::Pad','tvs_eng_mount_p2_pad')
doc.getObject('tvs_eng_mount_p2_pad').Profile = sketch_tvs_eng_mount_p2
doc.getObject('tvs_eng_mount_p2_pad').ReferenceAxis = (sketch_tvs_eng_mount_p2, ['N_Axis'])
doc.getObject('tvs_eng_mount_p2_pad').Direction = (0, 0, 1)
doc.getObject('tvs_eng_mount_p2_pad').Midplane = 0
doc.getObject('tvs_eng_mount_p2_pad').Reversed = 0
doc.getObject('tvs_eng_mount_p2_pad').Offset = 0
doc.getObject('tvs_eng_mount_p2_pad').Type = 0
doc.getObject('tvs_eng_mount_p2_pad').Length = tvs_eng_mount_p2_thickness
doc.getObject('tvs_eng_mount_p2_pad').TaperAngle = 0
doc.getObject('tvs_eng_mount_p2_pad').UseCustomVector = 0
doc.getObject('tvs_eng_mount_p2_pad').AlongSketchNormal = 1
doc.getObject('tvs_eng_mount_p2_pad').UpToFace = None
doc.recompute()

sketch_tvs_eng_mount_p2.Visibility = False
doc.recompute()

tvs_eng_mount_p2_object1.Visibility = False
doc.recompute()

tvs_eng_mount_p2_object2.Visibility = False
doc.recompute()


# Move/Rotate p2 into place.
x_displacement = chamber_length
doc.tvs_eng_mount_p2_body.Placement=App.Placement(App.Vector(x_displacement,0,0), App.Rotation(App.Vector(0,1,0),0), App.Vector(0,0,0))
doc.recompute()

z_displacement = tvs_eng_mount_p2_sep / 2
doc.tvs_eng_mount_p2_body.Placement=App.Placement(App.Vector(0,0,z_displacement), App.Rotation(App.Vector(0,1,0),0), App.Vector(0,0,0)).multiply(doc.tvs_eng_mount_p2_body.Placement)
doc.recompute()

# CLONE tvs_eng_mount_p2_body to tvs_eng_mount_p2_body_copy
doc.addObject('PartDesign::Body','tvs_eng_mount_p2_body_copy')
doc.addObject('PartDesign::FeatureBase','tvs_eng_mount_p2_body_clone')
doc.getObject('tvs_eng_mount_p2_body_clone').BaseFeature = doc.getObject('tvs_eng_mount_p2_body')
doc.getObject('tvs_eng_mount_p2_body_clone').Placement = doc.getObject('tvs_eng_mount_p2_body').Placement
doc.getObject('tvs_eng_mount_p2_body_clone').setEditorMode('Placement',0)
doc.getObject('tvs_eng_mount_p2_body_copy').Group = [doc.getObject('tvs_eng_mount_p2_body_clone')]
doc.getObject('tvs_eng_mount_p2_body_copy').Tip = doc.getObject('tvs_eng_mount_p2_body_clone')
doc.recompute()

# doc.getObject('tvs_eng_mount_p2_body_clone').ViewObject.Transparency=getattr(doc.getObject('tvs_eng_mount_p2_body').getLinkedObject(True).ViewObject,'Transparency',App.getDocument('Unnamed3').getObject('Clone').ViewObject.Transparency)
# doc.getObject('tvs_eng_mount_p2_body_clone').ViewObject.DisplayMode=getattr(doc.getObject('tvs_eng_mount_p2_body').getLinkedObject(True).ViewObject,'DisplayMode',App.getDocument('Unnamed3').getObject('Clone').ViewObject.DisplayMode)




# Move tvs_eng_mount_p2_body_copy over!
z_displacement = -(tvs_eng_mount_p2_sep + tvs_eng_mount_p2_thickness)
doc.tvs_eng_mount_p2_body_copy.Placement=App.Placement(App.Vector(0,0,z_displacement), App.Rotation(App.Vector(0,1,0),0), App.Vector(0,0,0))
doc.recompute()



