# -*- coding: utf-8 -*-
#
# Name: RPALoad.FCMacro
# Purpose: Given a RPA txt contour file and some additional values, generate the freecad file for the nozzle.
#

# Macro Begin: C:\Users\joema\OneDrive\Desktop\freecad\RPALoad.FCMacro +++++++++++++++++++++++++++++++++++++++++++++++++
import FreeCAD
import PartDesign
import Draft
import PartDesignGui
import csv
import re
import numpy as np
import math
import json
from BasicShapes import Shapes
from scipy import interpolate
from PySide import QtGui




# Parameters
outfile = "out_profile.txt"



# --------------------------------------------------------
# PART SPECIFICATIONS
# --------------------------------------------------------
# Injector combusion chamber housing
InjectorCont_height             = 20  # Length of combustion chamber that extends forward to accomodate injector components
InjectorCont_inner_radius       = 123 # Inside diameter of the injector assembly housing. - THIS IS SET LATER
InjectorCont_outer_radius       = 123 # Outside diameter of the injector assembly housing. - THIS IS SET LATER
InjectorCont_flange_width       = 10  # Additional length in radial direction
InjectorCont_flange_thickness   = 5   # Thickness of flange
InjectorCont_flange_hole_count  = 30  # Number of bolts to hold engine head plate on to Flange
InjectorCont_flange_hole_radius = 1.5 # Radius of holes for bolts.

InjectorCont_flange_oring_groove_depth = 1   # Depth of oring Groove
InjectorCont_flange_oring_groove_width = 1   # Width of oring Groove
InjectorCont_flange_oring_hole_gap    = 3   # Gap between hole and oring recess (For the o-ring)




# Endcap - the part that bolts on to the engine flange - where all propellants, etc are delivered
Endcap_radius = 123              # radius of cap - to suit flange - THIS IS SET LATER
Endcap_thickness = 5             # Thickness of cap.


# Overall dimensions of regenerative cooling
regen_thickness = 10             # Total thickness of regenerative shell, i.e. we displace the profile "thickness" mm in the Y direction.
innerwall_thickness = 3          # Thickness of material between chamber wall and the channel (y-dirction)


# Channel dimensions
channel_bottom_reduction = 10    # How far back do we want to bring the channel section in mm
channel_top_reduction  = 10      # How far forward do we want to bring the channel section in mm
channel_count         = 20       # Number of channels
channel_width_top     = 3
channel_width_throat  = 2
channel_width_bottom  = 3
channel_height_top    = 2
channel_height_throat = 4
channel_height_bottom = 2

# Coolant Entry
coolant_entry_ring_height     = 10  # Height if ring, that connects all the channels
coolant_entry_torus_thickness = 3   # Thickness of torus metal manifold at coolant exit (top of motor)


# Coolant Exit
coolant_exit_ring_height    = 10    # Height if ring, that connects all the channels
coolant_exit_torus_thickness = 3    # Thickness of torus metal manifold at coolant exit (top of motor)


#
# Basic physical parameters of the component
# tvs - Thrust Vector System
# eng - Engine
# mount - part of the mount system
# p1    - p for Part  ... #1
#
# desc: Component that is attached to the engine body - conduit for TVS force to pivot engine
#
tvs_eng_mount_p1_radius    = 0     # Inner Radius - THIS IS SET LATER
tvs_eng_mount_p1_angle     = 0     # Degrees - THIS IS SET LATER
tvs_eng_mount_p1_width     = 10    # mm - nominal arc - one point to other (straight line) distance
tvs_eng_mount_p1_thickness = 3     # thickness of this component
tvs_eng_mount_p1_height    = 30    # Height of the component
tvs_eng_mount_p1_clearance = 6     # Clearance on each side of the p2 part.




#
# Basic physical parameters of the component
# tvs - Thrust Vector System
# eng - Engine
# mount - part of the mount system
# p2    - p for Part  ... #2
#
# desc: Component that TVS rod attaches to, to pivot engine.
#       We actually have two of these per pivot, several mm apart, but we ony define ONE here.
#
tvs_eng_mount_p2_radial_offset   = 0   # How far from axis this component starts - THIS IS SET LATER!
tvs_eng_mount_p2_radius1         = 10    # outer radius of component
tvs_eng_mount_p2_radius2         = 5     # inner radius (hole) in the component
tvs_eng_mount_p2_circle_distance = 10    # Distance from outer surface of p1 to center of circle
tvs_eng_mount_p2_thickness       = 3     # thickness of this component
tvs_eng_mount_p2_gap             = 5     # Gap between two of these parts at BASE (arc length)
tvs_eng_mount_p2_base_width      = tvs_eng_mount_p1_height # We want it to FIT on P1.
tvs_eng_mount_p2_base_height     = 10    # Height of the component ...RADIALLY how far above p1
tvs_eng_mount_p2_sep             = 3     # Separation between the two p2 parts.



# Endcap has some points where we bolt a truss
# These 
endcap_mount_p1_radial_offset   = 0     # How far from axis this component starts - THIS IS SET LATER!
endcap_mount_p1_radius1         = 6     # outer radius of component
endcap_mount_p1_radius2         = 2     # inner radius (hole) in the component
endcap_mount_p1_circle_distance = 10    # Distance from outer surface of p1 to center of circle
endcap_mount_p1_thickness       = 5     # thickness of this component
endcap_mount_p1_gap             = 5     # Gap between two of these parts at BASE (arc length)
endcap_mount_p1_base_width      = 15    # nominal width
endcap_mount_p1_height_straight = 3     # From the base, we initially go up THIS many mm above.
endcap_mount_p1_base_height     = 3     # Height of the circular part of the component...above the base.
endcap_mount_p1_base_offset     = 3     # How much to move the hole away from center of radius1 circle - UP.
endcap_mount_p1_count           = 4     # Number of these mounts






# Injector body
injector_body_radius           = 123       # THIS IS SET LATER
injector_body_height           = 123       # THIS IS SET LATER
injector_body_fuel_hole_radius = 5         # The hole where the Pintle resides
injector_body_lox_inner_radius_outlet = 10 # radius - from x axis
injector_body_lox_outer_radius_outlet = 11 # radius - from x axis
injector_body_oring_groove_width      = 2  # width (in x dirction) of o-ring groove
injector_body_oring_groove_depth      = 2  # width (in radial dirction) of o-ring groove
injector_body_oring_offset            = 5  # How far in mm along x axis away from combustion chamber






# Variables
wire = []
channel_throat_radius = 99999       # This is radius to channel wall, closest to combustion chamber.  # Intentially set too high. Is deduced later.
channel_top_radius    = 0           # Radius of channel wall at the top of motor
channel_bottom_radius = 0           # Radius of channel wall at the bottom of motor
increment_distance = 1              # We approximate curved surfaces by breaking them down into small bits; what se specify here
overlap = 0.2                       # Because we create arcs as discrete straight lines, they won't 100% touch a surface at some points
                                    # We 













# ------------------------------------------------------------------------
# Prompt user for curve
# ------------------------------------------------------------------------
file_dialog = QtGui.QFileDialog()
rpa_file_path = file_dialog.getOpenFileName()[0]
print("\nImporting: " + rpa_file_path + "\n")


doc = App.newDocument()


# Make Groups
RegenCoolingChannels = App.ActiveDocument.addObject("App::DocumentObjectGroup", "RegenCoolingChannels")
MotorGroup = App.ActiveDocument.addObject("App::DocumentObjectGroup", "MotorGroup")
Tvc_Engine_Mounts = App.ActiveDocument.addObject("App::DocumentObjectGroup", "Tvc_Engine_Mounts")


folder = os.path.dirname(rpa_file_path)
outfile_path = folder + "\\" + outfile
print("Generating new contour file: ", outfile_path)

p = re.compile('^#')
firstline = 0

points = []
num_points = 0
linenum = 0
# x, y list of points separated, so we can utilise numpy gradient
x_points = []
y_points = []
with open(outfile_path, 'w') as f:
	with open(rpa_file_path) as rpa_file:
		content = rpa_file.readlines()
		for line in content:
			if p.match(line):
				continue
			else:
				num_points = num_points + 1
				linenum = linenum + 1
				if firstline == 0:
					firstline = 1
					f.write("i    x     y" + "\n")
				# print(linenum, "     ", line.strip())
				f.write(str(linenum) + "     " + line.strip() + "\n")
				cells = line.split()
				x = cells[0]
				y = cells[1]
				x_points.append(float(x))
				y_points.append(float(y))
				points.append([x, y])

	# print("Added ", num_points, " to file")
	# Initialise function to find gradient
	curve_grad = np.gradient(y_points, x_points)

	for i in range(1, num_points+1):
		x = float(points[-i][0])
		y = float(points[-i][1])

		

		# Adding thickness to the y-direction is not what we want. The thickness is length of vector tangent to surface.
        # y = float(y) + thickness

		# While we are at it, we find out what the point is out outter wall of channel
		# First we need to find vector that is tangent to the point we are interested in.
		grad_vector = [1, curve_grad[-i]]
		grad_vector_unit = np.round(grad_vector / np.linalg.norm(grad_vector),8)
		# print(grad_vector_unit)

		# Then we want to find the vector that is orthogonal to this vector
		if grad_vector_unit[1] == 0:
			orthogonal_vector = [0, 1]
		else:
			orthogonal_vector = [1, - 1 / grad_vector_unit[1]]
			orthogonal_vector = np.round(orthogonal_vector / np.linalg.norm(orthogonal_vector), 8)

		# We want the vector always pointing up in the y-direction (there are two vectors that are perpendicular, and this is the one we want)
		if orthogonal_vector[1] < 0:
			orthogonal_vector[0] = -1 * orthogonal_vector[0]
			orthogonal_vector[1] = -1 * orthogonal_vector[1]


		# Find the new location / point.
		# v = innerwall_thickness * orthogonal_vector
		v = np.multiply(orthogonal_vector, regen_thickness)
		new_x = x + v[0]
		new_y = y + v[1]

		linenum = linenum + 1
		# print(linenum, "     ", x, "     ", y)
		f.write(str(linenum) + "     " + str(new_x) + "     " + str(new_y) + "\n")


print("Created output file: ", outfile)


# this read the csv to generate the regenerative cooling unit.
with open(outfile_path) as csv_file:
	csv_reader = csv.DictReader(csv_file, delimiter=' ', skipinitialspace=True)
	line_count = 0
	for row in csv_reader:
		# for the first row print the headers
		if line_count == 0:
			print(f'Keys are: {", ".join(row)}\n')
			line_count += 1
		# for other rows extract the information
		x = row["x"]
		y = row["y"]

		# and create the geometry
		# print(x, " ", y)
		wire.append(FreeCAD.Vector(float(x),float(y),float(0))) # append the coordinates
		line_count += 1

	print(f'\nProcessed {line_count} lines.\n')
	wire_object = Draft.makeWire(wire,closed=True,face=False,support=None)   # create the wire open


doc.recompute()

sketch_nozzle = Draft.make_sketch([wire_object], autoconstraints=True, delete=False, radiusPrecision=0)
doc.recompute()

doc.addObject('PartDesign::Body','MotorBody')
doc.MotorBody.Group = [sketch_nozzle]
doc.recompute()

doc.getObject('Sketch').Support = (doc.getObject('XY_Plane'), [''])
doc.getObject('Sketch').MapMode = 'FlatFace'
doc.recompute()


doc.getObject('MotorBody').newObject('PartDesign::Revolution','Revolution')
doc.getObject('Revolution').Profile = sketch_nozzle
doc.getObject('Revolution').ReferenceAxis = (doc.getObject('X_Axis'), [''])
doc.getObject('Revolution').Angle = 360.0
doc.getObject('Revolution').Reversed = 1
doc.getObject('Sketch').Visibility = False
doc.recompute()

wire_object.Visibility = False
doc.recompute()

MotorGroup.addObjects([doc.getObject('MotorBody')])





# -----------------------------------------------------------------
# Calculate quantities for use later on
# -----------------------------------------------------------------

# Get min and max X points.
chamber_length = 0
for i in range(0, num_points):
	x = float(points[i][0])
	y = float(points[i][1])
	if i == 0:
		min_x = float(points[i][0])
		max_x = float(min_x)
		prev_x = x
		prev_y = y
		continue
	else:
		min_x = min(min_x, float(points[i][0]))
		max_x = max(max_x, float(points[i][0]))

	if y != prev_y and chamber_length == 0:
		chamber_length = prev_x

	prev_x = x
	prev_y = y
    
print("Min x: ", min_x)
print("Max x: ", max_x)
print("chamber_length: ", chamber_length)

# Calculate angle we must revolve the sketch to ensure we get the channel width desired.
top_radius = float(y_points[0]) + innerwall_thickness
combustion_chamber_internal_radius = y_points[0]
combustion_chamber_external_radius = combustion_chamber_internal_radius + regen_thickness
circumference = 2 * np.pi * top_radius
angle_rotation = 360 * channel_width_top / circumference

print("Radius: ", top_radius)
print("Circumference: ", circumference)
print("ar: ", angle_rotation)







# ------------------------------------------------------------------------
# Create front part of motor - housing for the injectors
# ------------------------------------------------------------------------
# Extend the combustion chamber....
InjectorCont = Shapes.addTube(FreeCAD.ActiveDocument, "InjectorCont")
InjectorCont.Height      = InjectorCont_height
InjectorCont.InnerRadius = combustion_chamber_internal_radius
InjectorCont.OuterRadius = combustion_chamber_external_radius
InjectorCont.Placement=App.Placement(App.Vector(0,0,0), App.Rotation(App.Vector(0,1,0),-90), App.Vector(0,0,0))
doc.recompute()


# Create flange
# InjectorCont_flange_hole_count
# InjectorCont_flange_hole_radius
InjectorCont_flange = Shapes.addTube(FreeCAD.ActiveDocument, "InjectorCont_flange")
InjectorCont_flange.Height      = InjectorCont_flange_thickness
InjectorCont_flange.InnerRadius = combustion_chamber_internal_radius
InjectorCont_flange.OuterRadius = combustion_chamber_external_radius + InjectorCont_flange_width
x_displacement = -InjectorCont_height
InjectorCont_flange.Placement=App.Placement(App.Vector(x_displacement,0,0), App.Rotation(App.Vector(0,1,0),-90), App.Vector(0,0,0))
doc.recompute()


# Group for flange holes
injectorcont_flange_holes_group = App.ActiveDocument.addObject("App::DocumentObjectGroup", "injectorcont_flange_holes_group")


# Create holes for flange
holes = []
injectorcont_flange_hole1 = doc.addObject("Part::Cylinder", "injectorcont_flange_hole1")
injectorcont_flange_hole1.Radius = InjectorCont_flange_hole_radius
injectorcont_flange_hole1.Height = InjectorCont_flange_thickness
x_displacement = -InjectorCont_height
z_displacement = combustion_chamber_external_radius + InjectorCont_flange_width / 2
injectorcont_flange_hole1.Placement=App.Placement(App.Vector(x_displacement,0,z_displacement), App.Rotation(App.Vector(0,1,0),-90), App.Vector(0,0,0))
# injectorcont_flange_holes_group.addObjects([doc.getObject('injectorcont_flange_hole1')])
doc.recompute()
holes.append(injectorcont_flange_hole1)


# Copy these holes InjectorCont_flange_hole_count - 1 times
rotation_increment = 360 / InjectorCont_flange_hole_count
for i in range(1,InjectorCont_flange_hole_count):
	j = i + 1
	body_name = 'injectorcont_flange_hole' + str(j)
	clone_name = 'injectorcont_flange_hole1_clone' + str(j)
	doc.addObject('PartDesign::Body', body_name)
	doc.addObject('PartDesign::FeatureBase',clone_name)
	doc.getObject(clone_name).BaseFeature = doc.getObject('injectorcont_flange_hole1')
	doc.getObject(clone_name).Placement = doc.getObject('injectorcont_flange_hole1').Placement
	doc.getObject(clone_name).setEditorMode('Placement',0)
	doc.getObject(body_name).Group = [doc.getObject(clone_name)]
	doc.getObject(body_name).Tip = doc.getObject(clone_name)
	x_displacement = -InjectorCont_height
	z_displacement = combustion_chamber_external_radius + InjectorCont_flange_width / 2
	x_rotation = i * rotation_increment
	doc.getObject(body_name).Placement=App.Placement(App.Vector(0,0,0), App.Rotation(App.Vector(1,0,0),x_rotation), App.Vector(0,0,0)).multiply(doc.getObject(body_name).Placement)
	holes.append(doc.getObject(body_name))
	doc.recompute()




# -------------------------------------------
# Combine P1, 2 x P2 into a Group and union them...
# -------------------------------------------
doc.addObject("Part::MultiFuse","injectorcont_flange_holes_fusion")
doc.injectorcont_flange_holes_fusion.Shapes = holes
doc.injectorcont_flange_holes_group.addObject(doc.injectorcont_flange_holes_fusion)
doc.recompute()



# ----------------------------------------------
# Subtract holes from flange
# ----------------------------------------------
doc.addObject("Part::Cut","InjectorCont_flange_with_holes")
doc.InjectorCont_flange_with_holes.Base = doc.InjectorCont_flange
doc.InjectorCont_flange_with_holes.Tool = doc.injectorcont_flange_holes_fusion
doc.injectorcont_flange_holes_group.removeObject(doc.injectorcont_flange_holes_fusion)
doc.injectorcont_flange_holes_group.addObject(doc.InjectorCont_flange_with_holes)

# NOTE: We use want to duplicate doc.InjectorCont_flange_with_holes



# ----------------------------------------------
# Create o-Ring groove
# ----------------------------------------------
# InjectorCont_flange_oring_groove_depth
groove_y_offset = combustion_chamber_external_radius + InjectorCont_flange_width / 2  - InjectorCont_flange_hole_radius - InjectorCont_flange_oring_hole_gap
groove_x_offset = -InjectorCont_height - InjectorCont_flange_thickness + InjectorCont_flange_oring_groove_depth
groove_points = [[0,0], [0,InjectorCont_flange_oring_groove_width], [-InjectorCont_flange_oring_groove_depth, InjectorCont_flange_oring_groove_width], [-InjectorCont_flange_oring_groove_depth, 0], [0,0]]
print(groove_points)

groove_points_wire = []
for i in range(0,len(groove_points)):
	x = groove_x_offset + groove_points[i][0]
	y = groove_y_offset + groove_points[i][1]
	groove_points_wire.append(FreeCAD.Vector(float(x),float(y),float(0))) # append the coordinates


groove_oring_wire_object = Draft.makeWire(groove_points_wire,closed=False,face=False,support=None)   # create the wire open
doc.recompute()

sketch_oring_groove = Draft.make_sketch([groove_oring_wire_object], autoconstraints=True, delete=False, radiusPrecision=0)
doc.recompute()



# ----------------------------------------------
# Revolve the Sketch to create the trench (groove)
# ----------------------------------------------

doc.addObject('PartDesign::Body','ORing_Groove_Body')
doc.getObject('ORing_Groove_Body').Group = [sketch_oring_groove]
doc.recompute()

sketch_oring_groove.Support = (doc.getObject('XY_Plane'), [''])
sketch_oring_groove.MapMode = 'FlatFace'
doc.recompute()


### Begin command PartDesign_Revolution
doc.getObject('ORing_Groove_Body').newObject('PartDesign::Revolution','oring_groove_revolution')
doc.getObject('oring_groove_revolution').Profile = sketch_oring_groove
doc.getObject('oring_groove_revolution').ReferenceAxis = (doc.getObject('X_Axis'), [''])
doc.getObject('oring_groove_revolution').Angle = 360.0
sketch_oring_groove.Visibility = False
doc.getObject('oring_groove_revolution').Midplane = 0
doc.getObject('oring_groove_revolution').Reversed = 0
doc.recompute()




# ----------------------------------------------
# Subtract o-Ring from flange
# ----------------------------------------------
doc.addObject("Part::Cut","InjectorCont_flange_final")
doc.InjectorCont_flange_final.Base = doc.getObject("InjectorCont_flange_with_holes")
doc.InjectorCont_flange_final.Tool = doc.getObject('ORing_Groove_Body')
doc.recompute()


# ------------------------------------------------------------------------
# this read the csv to generate the channels
# NOTE, we need to take into account the channel specs...this is to allow us to use the profile to generate 
# channels that match curvature of the nozzle profile.
# This takes 3 steps
# - load data into array  - This was done above and is in list: points
# - process array of data to conform with design settings
# - Parse
# ------------------------------------------------------------------------

# channel_points = []  # Holds points for single channel






# Start generating "inner" points of channel
channel_points = []           # Points closest to Combustion chamber

channel_points_raw = []       # Where we hold the points in raw format, so we can go over this to generate other points.
channel_points_raw_x = []
channel_points_raw_y = []
channel_points_outter = []    # Points furtherest from Combustion chamber
num_points_channel = 0
for i in range(0, num_points-1):
	x =  float(points[i][0])
	y =  float(points[i][1])

	if i != num_points:
		next_x =  float(points[i+1][0])
		next_y =  float(points[i+1][1])
	
	
	# Make sure we don't breach top of nozzle with channel
	if x < min_x + channel_top_reduction:
		if next_x < min_x + channel_top_reduction:
			continue
		else:
			f = interpolate.interp1d([x, next_x], [y, next_y])
			new_x = min_x + channel_top_reduction
			new_y = f(new_x)
			# Make sure we don't breach bottom of nozzle with channel
	elif x > max_x - channel_bottom_reduction:
		if prev_x < max_x - channel_bottom_reduction:
			f = interpolate.interp1d([prev_x, x], [prev_y, y])
			new_x = max_x - channel_bottom_reduction
			new_y = f(new_x)
		else:
			continue
	else:
		new_x = x
		new_y = y




	
	# While we are at it, we find out what the point is out outter wall of channel
	# First we need to find vector that is tangent to the point we are interested in.
	grad_vector = [1, curve_grad[i]]
	grad_vector_unit = np.round(grad_vector / np.linalg.norm(grad_vector),8)

	# Then we want to find the vector that is orthogonal to this vector
	if grad_vector_unit[1] == 0:
		orthogonal_vector = [0, 1]
	else:
		orthogonal_vector = [1, - 1 / grad_vector_unit[1]]
		orthogonal_vector = np.round(orthogonal_vector / np.linalg.norm(orthogonal_vector), 8)

	# We want the vector always pointing up in the y-direction (there are two vectors that are perpendicular, and this is the one we want)
	if orthogonal_vector[1] < 0:
		orthogonal_vector[0] = -1 * orthogonal_vector[0]
		orthogonal_vector[1] = -1 * orthogonal_vector[1]


	# Find the new location / point.
	# v = innerwall_thickness * orthogonal_vector
	v = np.multiply(orthogonal_vector, innerwall_thickness)
	new_x = new_x + v[0]
	new_y = new_y + v[1]


	# We push data on to these lists to make the step of creating the outer edge of channel a little less complex.
	channel_points_raw_x.append(float(new_x))
	channel_points_raw_y.append(float(new_y))
	channel_points_raw.append([float(new_x),float(new_y)])
	channel_throat_radius = min(channel_throat_radius, float(new_y))
	num_points_channel  = num_points_channel  + 1
	
	# now add points to List that will be used to do the drawin.g
	channel_points.append(FreeCAD.Vector(float(new_x),float(new_y),float(0))) # append the coordinates


	prev_x = x
	prev_y = y

# Get radius of channel at top and bottom. Required later for calculating the height of channel
channel_bottom_radius = channel_points_raw_y[0]
channel_top_radius    = channel_points_raw_y[len(channel_points_raw_y)-1]


# Start generating "outer" points of channel
channel_outer_points_raw = []
curve_grad = np.gradient(channel_points_raw_y, channel_points_raw_x)
location   = 2    # 2 is for below throat, near exist   #1 is for above throat
for i in range(1, num_points_channel +1):
	x = float(channel_points_raw[-i][0])
	y = float(channel_points_raw[-i][1])

	# Work out if are moving from the bottom of nozzle to top of nozzle (combustion chamber)
	if prev_y  < y:
		location = 1

	if location == 2:
		r = (y - channel_throat_radius)/(channel_bottom_radius - channel_throat_radius)
		channel_height = channel_height_bottom * r  +  channel_height_throat * (1 - r)
	elif location == 1:
		r = (y - channel_throat_radius)/(channel_top_radius - channel_throat_radius)
		channel_height = channel_height_top * r  +  channel_height_throat * (1 - r)
	else:
		print("ERROR. UNEXPECTED LOCATION: ", location)


	# Calculate channel height at this point along
	# channel_height = channel_height_top

	# Adding thickness to the y-direction is not what we want. The thickness is length of vector tangent to surface.
	# y = float(y) + thickness
	# While we are at it, we find out what the point is out outter wall of channel
	# First we need to find vector that is tangent to the point we are interested in.
	grad_vector = [1, curve_grad[-i]]
	grad_vector_unit = np.round(grad_vector / np.linalg.norm(grad_vector),8)
	# print(grad_vector_unit)

	# Then we want to find the vector that is orthogonal to this vector
	if grad_vector_unit[1] == 0:
		orthogonal_vector = [0, 1]
	else:
		orthogonal_vector = [1, - 1 / grad_vector_unit[1]]
		orthogonal_vector = np.round(orthogonal_vector / np.linalg.norm(orthogonal_vector), 8)

	# We want the vector always pointing up in the y-direction (there are two vectors that are perpendicular, and this is the one we want)
	if orthogonal_vector[1] < 0:
		orthogonal_vector[0] = -1 * orthogonal_vector[0]
		orthogonal_vector[1] = -1 * orthogonal_vector[1]


	# Find the new location / point.
	# v = innerwall_thickness * orthogonal_vector
	v = np.multiply(orthogonal_vector, channel_height)
	new_x = x + v[0]
	new_y = y + v[1]

	linenum = linenum + 1
	# print(linenum, "     ", x, "     ", y)
	# f.write(str(linenum) + "     " + str(new_x) + "     " + str(new_y) + "\n")
	channel_points.append(FreeCAD.Vector(float(new_x),float(new_y),float(0))) # append the coordinates
	channel_outer_points_raw.append([float(new_x),float(new_y)])

	prev_x = x
	prev_y = y


channel_object = Draft.makeWire(channel_points,closed=True,face=False,support=None)   # create the wire open
doc.recompute()

sketch_channel = Draft.make_sketch([channel_object], autoconstraints=True, delete=False, radiusPrecision=0)
doc.recompute()


print(f'\nProcessed {line_count} lines.\n')




# Create the 3-d representation of the channel
doc.addObject('PartDesign::Body','BodyChannel')
doc.BodyChannel.Group = [sketch_channel]
doc.recompute()

sketch_channel.Support = (doc.getObject('XY_Plane'), [''])
sketch_channel.MapMode = 'FlatFace'
doc.recompute()



doc.getObject('BodyChannel').newObject('PartDesign::Revolution','RevolutionChannel')
doc.getObject('RevolutionChannel').Profile = sketch_channel
doc.getObject('RevolutionChannel').ReferenceAxis = (doc.getObject('X_Axis'), [''])
doc.getObject('RevolutionChannel').Angle = angle_rotation
doc.getObject('RevolutionChannel').Reversed = 1
sketch_channel.Visibility = False
doc.recompute()



channel_object.Visibility = False
doc.recompute()




# Make channel_count copies and rotate these.
RegenCoolingChannels.addObjects([doc.getObject('BodyChannel')])
for i in range(1,channel_count):
	channel_copy = doc.copyObject(doc.getObject('BodyChannel'), True)
	angle = (360 / channel_count) * i
	channel_copy.Placement=App.Placement(App.Vector(0,0,0), App.Rotation(App.Vector(1,0,0),angle), App.Vector(0,0,0))
	RegenCoolingChannels.addObjects([channel_copy])



# Add the coolant exit
doc.addObject("Part::Cylinder","Cylinder_1")
doc.ActiveObject.Label = "Cylinder_coolant_exit_build1"
doc.recompute()
doc.getObject('Cylinder_1').Radius = top_radius
doc.getObject('Cylinder_1').Height = coolant_exit_ring_height


doc.addObject("Part::Cylinder","Cylinder_2")
doc.ActiveObject.Label = "Cylinder_coolant_exit_build2"
doc.recompute()
doc.getObject('Cylinder_2').Radius = top_radius + channel_height_top
doc.getObject('Cylinder_2').Height = coolant_exit_ring_height

doc.addObject("Part::Cut","Coolant_exit_ring")
doc.Coolant_exit_ring.Base = doc.Cylinder_2
doc.Coolant_exit_ring.Tool = doc.Cylinder_1
doc.recompute()



# Next we rotate and move this into place
displacement = coolant_exit_ring_height + channel_top_reduction
angle_rotation = -90
# doc.Coolant_exit_ring.Placement=App.Placement(App.Vector(0,0,0), App.Rotation(App.Vector(0,1,0),-90), App.Vector(0,0,0))
doc.Coolant_exit_ring.Placement=App.Placement(App.Vector(displacement,0,0), App.Rotation(App.Vector(0,1,0),angle_rotation), App.Vector(0,0,0))

RegenCoolingChannels.addObjects([doc.getObject('Coolant_exit_ring')])




# ------------------------------------------------------------------------
# Add the coolant entry ring
# We use the channel data at exit and work "back". Because the angle of the exit is normally small
# we use the x-displacement, not the curved length as the height of ring
#
# This is the INNER part of the coolant exit ring. (part 1 of 3)
# ------------------------------------------------------------------------
coolant_exit_ring_points = []
for i in range(1, num_points_channel +1):
	x = float(channel_points_raw[-i][0])
	y = float(channel_points_raw[-i][1])
	
	if i == 1:
		x_start = x

	if x_start - x > coolant_entry_ring_height:
		f = interpolate.interp1d([prev_x, x], [prev_y, y])
		xx = x_start - coolant_entry_ring_height
		yy = f(xx)
		coolant_exit_ring_points.append([xx, yy])
		break
	else:
		xx = x
		yy = y

	coolant_exit_ring_points.append([xx, yy])
	# print("added xx, yy: ", xx, ", ", yy)



	prev_x = x
	prev_y = y


# Reverse list, so we can continue to add points in
coolant_exit_ring_points.reverse()



# This is the OUTER part of the coolant exit ring. (part 2 of 3)
for i in range(0, num_points_channel):
	x = float(channel_outer_points_raw[i][0])
	y = float(channel_outer_points_raw[i][1])
	
	if i == 0:
		x_start = x

	if x_start - x > coolant_entry_ring_height:
		f = interpolate.interp1d([prev_x, x], [prev_y, y])
		xx = x_start - coolant_entry_ring_height
		yy = f(xx)
		coolant_exit_ring_points.append([xx, yy])
		break
	else:
		xx = x
		yy = y

	coolant_exit_ring_points.append([xx, yy])
	# print("added xx, yy: ", xx, ", ", yy)

	prev_x = x
	prev_y = y



# Now that we have Inner and Outer points, we create a sketch.
coolant_entry_ring = []
for i in range(1, len(coolant_exit_ring_points)):
	x = coolant_exit_ring_points[i][0]
	y = coolant_exit_ring_points[i][1]
	coolant_entry_ring.append(FreeCAD.Vector(x,y,float(0))) # append the coordinates


coolant_entry_ring_object = Draft.makeWire(coolant_entry_ring,closed=True,face=False,support=None)   # create the wire open
doc.recompute()

sketch_coolant_entry_ring = Draft.make_sketch([coolant_entry_ring_object], autoconstraints=True, delete=False, radiusPrecision=0)
doc.recompute()


# Revolve sketch to finish off coolant entry ring
doc.addObject('PartDesign::Body','Coolant_entry_ring_body')
doc.Coolant_entry_ring_body.Group = [sketch_coolant_entry_ring]

sketch_coolant_entry_ring.Support = (doc.getObject('XY_Plane040'), [''])
sketch_coolant_entry_ring.MapMode = 'FlatFace'
doc.recompute()

doc.getObject('Coolant_entry_ring_body').newObject('PartDesign::Revolution','Coolant_entry_ring_revolution')
doc.getObject('Coolant_entry_ring_revolution').Profile = sketch_coolant_entry_ring
# doc.getObject('Coolant_entry_ring_revolution').ReferenceAxis = (doc.getObject('X_Axis040'), [''])
doc.getObject('Coolant_entry_ring_revolution').ReferenceAxis = (doc.getObject('X_Axis'), [''])
doc.getObject('Coolant_entry_ring_revolution').Angle = 360.000000
doc.getObject('Coolant_entry_ring_revolution').Midplane = 0
doc.getObject('Coolant_entry_ring_revolution').Reversed = 0
doc.recompute()

sketch_coolant_entry_ring.Visibility = False
doc.recompute()

coolant_entry_ring_object.Visibility = False
doc.recompute()


# Add to Regen Cooling components
RegenCoolingChannels.addObjects([doc.getObject('Coolant_entry_ring_body')])
doc.recompute()






# ------------------------------------------------------------------------
# Half-Torus - Coolant cooling exit
# ------------------------------------------------------------------------
doc.addObject("Part::Torus","Coolant_exit_Torus")
doc.ActiveObject.Label = "Coolant_exit_Torus"


doc.getObject('Coolant_exit_Torus').Radius1 = top_radius + channel_height_top
doc.getObject('Coolant_exit_Torus').Radius2 = coolant_exit_ring_height / 2
doc.getObject('Coolant_exit_Torus').Angle1 = '-90.00 deg'
doc.getObject('Coolant_exit_Torus').Angle2 = '90.00 deg'

displacement = channel_top_reduction + coolant_exit_ring_height / 2
angle_rotation = -90
doc.getObject('Coolant_exit_Torus').Placement=App.Placement(App.Vector(displacement,0,0), App.Rotation(App.Vector(0,1,0),angle_rotation), App.Vector(0,0,0))
doc.recompute()


# Add to Regen Cooling components
RegenCoolingChannels.addObjects([doc.getObject('Coolant_exit_Torus')])
doc.recompute()





# ------------------------------------------------------------------------
# Coolant Entry 1/2 "torus shaped" object
# This is the 1/2 torus cavity that bounds the coolant entry ring.
# ------------------------------------------------------------------------
coolant_entry_torus_points = []
for i in range(0, num_points_channel):
	x = float(channel_outer_points_raw[i][0])
	y = float(channel_outer_points_raw[i][1])
	
	if i == 0:
		x_start = x
		min_x = x
		max_x = x
		min_y = y
		max_y = y

	if x_start - x > coolant_entry_ring_height:
		f = interpolate.interp1d([prev_x, x], [prev_y, y])
		xx = x_start - coolant_entry_ring_height
		yy = f(xx)
		coolant_entry_torus_points.append([xx, yy])
		min_x = min(min_x, xx)
		max_x = max(max_x, xx)
		min_y = min(min_y, yy)
		max_y = max(max_y, yy)
		break
	else:
		xx = x
		yy = y

	min_x = min(min_x, xx)
	max_x = max(max_x, xx)
	min_y = min(min_y, yy)
	max_y = max(max_y, yy)
	coolant_entry_torus_points.append([xx, yy])
	# print("added xx, yy: ", xx, ", ", yy)

	prev_x = x
	prev_y = y


# Now we find "mid-point" between (min_x, min_y) and (max_x, max_y)
f = interpolate.interp1d([min_x, max_x], [min_y, max_y])
middle_x = (min_x + max_x) / 2
middle_y = f(middle_x)
gradient_angle = math.atan((max_y - min_y) / (max_x - min_x)) * 180 / np.pi

print("middle_x, middle_y: ", middle_x, ", ", middle_y)
print("Angle of strip: ", gradient_angle)


coolant_entry_torus_points.reverse()

# Now we create approximation of a circule ( 5 degrees apart ) to make the "torus" like cavity at coolant entry.
step_size = 5   # number of degrees
# for i in range(step_size - gradient_angle, 180 - (step_size - gradient_angle), step_size):
positions = int(180 / step_size)
for i in range(1, positions - 1):
	angle = (i * step_size + gradient_angle) * (np.pi / 180)
	# print("i, Angle: " , i, ", ", angle)
	xx = middle_x + (coolant_entry_ring_height / 2) * math.cos(angle)
	yy = middle_y + (coolant_entry_ring_height / 2) * math.sin(angle)
	coolant_entry_torus_points.append([xx, yy])


# Now that we have Inner and Outer points, we create a sketch.
coolant_entry_torus = []
for i in range(0, len(coolant_entry_torus_points)):
	x = coolant_entry_torus_points[i][0]
	y = coolant_entry_torus_points[i][1]
	coolant_entry_torus.append(FreeCAD.Vector(x,y,float(0))) # append the coordinates


coolant_entry_torus_object = Draft.makeWire(coolant_entry_torus,closed=True,face=False,support=None)   # create the wire open
doc.recompute()

sketch_coolant_entry_torus = Draft.make_sketch([coolant_entry_torus_object], autoconstraints=True, delete=False, radiusPrecision=0)
doc.recompute()


# Revolve coolant entry torus sketch to finish off coolant entry ring
doc.addObject('PartDesign::Body','Coolant_entry_torus_body')
doc.Coolant_entry_torus_body.Group = [sketch_coolant_entry_torus]

sketch_coolant_entry_torus.Support = (doc.getObject('XY_Plane041'), [''])
sketch_coolant_entry_torus.MapMode = 'FlatFace'
doc.recompute()

doc.getObject('Coolant_entry_torus_body').newObject('PartDesign::Revolution','Coolant_entry_torus_revolution')
doc.getObject('Coolant_entry_torus_revolution').Profile = sketch_coolant_entry_torus
# doc.getObject('Coolant_entry_torus_revolution').ReferenceAxis = (doc.getObject('X_Axis041'), [''])
doc.getObject('Coolant_entry_torus_revolution').ReferenceAxis = (doc.getObject('X_Axis'), [''])
doc.getObject('Coolant_entry_torus_revolution').Angle = 360.000000
doc.getObject('Coolant_entry_torus_revolution').Midplane = 0
doc.getObject('Coolant_entry_torus_revolution').Reversed = 0
doc.recompute()

sketch_coolant_entry_torus.Visibility = False
doc.recompute()

coolant_entry_torus_object.Visibility = False
doc.recompute()


# Add to Regen Cooling components
RegenCoolingChannels.addObjects([doc.getObject('Coolant_entry_torus_body')])
doc.recompute()







######################################################################
# Create Coolant Exit OUTSIDE Torus (Top of the motor)
# Half-Torus - Coolant cooling exit
doc.addObject("Part::Torus","Coolant_outside_exit_Torus")
doc.ActiveObject.Label = "Coolant_outside_exit_Torus"


doc.getObject('Coolant_outside_exit_Torus').Radius1 = top_radius + channel_height_top
doc.getObject('Coolant_outside_exit_Torus').Radius2 = coolant_exit_torus_thickness + coolant_exit_ring_height / 2
doc.getObject('Coolant_outside_exit_Torus').Angle1 = '-90.00 deg'
doc.getObject('Coolant_outside_exit_Torus').Angle2 = '90.00 deg'

displacement = channel_top_reduction + coolant_exit_ring_height / 2
angle_rotation = -90
doc.getObject('Coolant_outside_exit_Torus').Placement=App.Placement(App.Vector(displacement,0,0), App.Rotation(App.Vector(0,1,0),angle_rotation), App.Vector(0,0,0))
doc.recompute()


# Add to Regen Cooling components
MotorGroup.addObjects([doc.getObject('Coolant_outside_exit_Torus')])
doc.recompute()







######################################################################
# Create 1/2 "torus shaped" manifold that surrounds "torus shaped" cavity at Coolant entry point. (bottom of rocket motor)
coolant_outside_entry_torus_points = []
for i in range(0, num_points_channel):
	x = float(channel_outer_points_raw[i][0])
	y = float(channel_outer_points_raw[i][1])
	
	if i == 0:
		x_start = x
		min_x = x
		max_x = x
		min_y = y
		max_y = y

	if x_start - x > coolant_entry_ring_height:
		f = interpolate.interp1d([prev_x, x], [prev_y, y])
		xx = x_start - coolant_entry_ring_height
		yy = f(xx)
		coolant_outside_entry_torus_points.append([xx, yy])
		min_x = min(min_x, xx)
		max_x = max(max_x, xx)
		min_y = min(min_y, yy)
		max_y = max(max_y, yy)
		break
	else:
		xx = x
		yy = y

	min_x = min(min_x, xx)
	max_x = max(max_x, xx)
	min_y = min(min_y, yy)
	max_y = max(max_y, yy)
	coolant_outside_entry_torus_points.append([xx, yy])
	# print("added xx, yy: ", xx, ", ", yy)

	prev_x = x
	prev_y = y


# Now we find "mid-point" between (min_x, min_y) and (max_x, max_y)
f = interpolate.interp1d([min_x, max_x], [min_y, max_y])
middle_x = (min_x + max_x) / 2
middle_y = f(middle_x)
gradient_angle = math.atan((max_y - min_y) / (max_x - min_x)) * 180 / np.pi

print("middle_x, middle_y: ", middle_x, ", ", middle_y)
print("Angle of strip: ", gradient_angle)


coolant_outside_entry_torus_points.reverse()

# Now we create approximation of a circule ( 5 degrees apart ) to make the "torus" like cavity at coolant entry.
step_size = 5   # number of degrees
# for i in range(step_size - gradient_angle, 180 - (step_size - gradient_angle), step_size):
positions = int(180 / step_size)
for i in range(0, positions+1):
	angle = (i * step_size + gradient_angle) * (np.pi / 180)
	# print("iii, Angle: " , i, ", ", angle)
	xx = middle_x + (coolant_entry_torus_thickness + coolant_entry_ring_height / 2) * math.cos(angle)
	yy = middle_y + (coolant_entry_torus_thickness + coolant_entry_ring_height / 2) * math.sin(angle)
	coolant_outside_entry_torus_points.append([xx, yy])


# Now that we have all points that make up 1/2 semi-torus, we create a sketch.
coolant_outside_entry_torus = []
for i in range(0, len(coolant_outside_entry_torus_points)):
	x = coolant_outside_entry_torus_points[i][0]
	y = coolant_outside_entry_torus_points[i][1]
	coolant_outside_entry_torus.append(FreeCAD.Vector(x,y,float(0))) # append the coordinates


coolant_outside_entry_torus_object = Draft.makeWire(coolant_outside_entry_torus,closed=True,face=False,support=None)   # create the wire open
doc.recompute()

sketch_coolant_outside_entry_torus = Draft.make_sketch([coolant_outside_entry_torus_object], autoconstraints=True, delete=False, radiusPrecision=0)
doc.recompute()


# Revolve coolant entry torus sketch to finish off coolant entry ring
doc.addObject('PartDesign::Body','Coolant_outside_entry_torus_body')
doc.Coolant_outside_entry_torus_body.Group = [sketch_coolant_outside_entry_torus]

sketch_coolant_outside_entry_torus.Support = (doc.getObject('XY_Plane042'), [''])
sketch_coolant_outside_entry_torus.MapMode = 'FlatFace'
doc.recompute()

doc.getObject('Coolant_outside_entry_torus_body').newObject('PartDesign::Revolution','Coolant_outside_entry_torus_revolution')
doc.getObject('Coolant_outside_entry_torus_revolution').Profile = sketch_coolant_outside_entry_torus
#doc.getObject('Coolant_outside_entry_torus_revolution').ReferenceAxis = (doc.getObject('X_Axis042'), [''])
doc.getObject('Coolant_outside_entry_torus_revolution').ReferenceAxis = (doc.getObject('X_Axis'), [''])
doc.getObject('Coolant_outside_entry_torus_revolution').Angle = 360.000000
doc.getObject('Coolant_outside_entry_torus_revolution').Midplane = 0
doc.getObject('Coolant_outside_entry_torus_revolution').Reversed = 0
doc.recompute()

sketch_coolant_outside_entry_torus.Visibility = False
doc.recompute()

coolant_outside_entry_torus_object.Visibility = False
doc.recompute()


# Add to Regen Cooling components
MotorGroup.addObjects([doc.getObject('Coolant_outside_entry_torus_body')])
doc.recompute()







# --------------------------------------------------------
# Create Wire of TVS Engine Mount P1 component
# This part is created as if looking axially along the rocket engines
# --------------------------------------------------------
# We visualise what this will look like
#
#           .  . 
#        .  .  .   .  
#     .   .      .   .
#      .           .   
#                      
#                       
# ........................#
#

points = []
tvs_eng_mount_p1_radius = combustion_chamber_internal_radius + regen_thickness - overlap # Outside of combustion chamber, where p1 mates to ending

# Based on separation of plates, thickness and clearance, work out angle to sweep.
tvs_eng_mount_p1_width = tvs_eng_mount_p2_thickness * 2 + tvs_eng_mount_p2_gap + tvs_eng_mount_p1_clearance * 2
tvs_eng_mount_p1_angle = math.acos(-(tvs_eng_mount_p1_width ** 2 - tvs_eng_mount_p1_radius ** 2 - tvs_eng_mount_p1_radius ** 2)/(2 * tvs_eng_mount_p1_radius * tvs_eng_mount_p1_radius)) * 180 / np.pi

# Starting point
x = 0
y = tvs_eng_mount_p1_radius
points.append([x, y])



# Form indie part of the component
segment_length = 2 * np.pi * tvs_eng_mount_p1_radius * tvs_eng_mount_p1_angle / 360
segment_count = int(np.floor(segment_length / increment_distance))
angle = segment_count / (segment_length / increment_distance) * tvs_eng_mount_p1_angle
for i in range(1,segment_count):
	theta = (i / segment_count) * angle * (np.pi / 180)
	x = tvs_eng_mount_p1_radius * np.sin(theta)
	y = tvs_eng_mount_p1_radius * np.cos(theta)
	points.append([x, y])


# Add the last point on the circular segment
x = tvs_eng_mount_p1_radius * np.sin(tvs_eng_mount_p1_angle * (np.pi / 180))
y = tvs_eng_mount_p1_radius * np.cos(tvs_eng_mount_p1_angle * (np.pi / 180))
points.append([x,y])


# Go out by "thickness" amount
v_orth = [np.sin(tvs_eng_mount_p1_angle * (np.pi / 180)), np.cos(tvs_eng_mount_p1_angle * (np.pi / 180))]
x = x + tvs_eng_mount_p1_thickness * np.sin(tvs_eng_mount_p1_angle * (np.pi / 180))
y = y + tvs_eng_mount_p1_thickness * np.cos(tvs_eng_mount_p1_angle * (np.pi / 180))
points.append([x,y])



# Now we need to the 'circle" bit back
x_start = x
y_start = y


r = tvs_eng_mount_p1_radius + tvs_eng_mount_p1_thickness
segment_length = 2 * np.pi * r * tvs_eng_mount_p1_angle / 360
segment_count = int(np.floor(segment_length / increment_distance))
angle = segment_count / (segment_length / increment_distance) * tvs_eng_mount_p1_angle * (np.pi / 180)
for i in range(1,segment_count):
	theta = (i / segment_count) * tvs_eng_mount_p1_angle * (np.pi / 180)
	x = r * np.sin(angle - theta)
	y = r * np.cos(angle - theta)
	points.append([x, y])


# Add the last point on the circular segment
phi = 0
x = r * np.sin(phi * (np.pi / 180))
y = r * np.cos(phi * (np.pi / 180))
points.append([x,y])



# Finishing point
x = 0
y = tvs_eng_mount_p1_radius
points.append([x, y])




# ---------------------------------------------------------------
# Create the other component, p2 of the TVS  This radially attaches to p1 component.
# This part is created if looking from side of engine (not radially, not axially)
# 
# We only define ONE of these and we pad, rotate, etc later on.
# ---------------------------------------------------------------
points2 = []

# We visualise what this will look like
#
#           .  . 
#        .        .  
#     .      .       .
#    .      . .        .
#   .        .          .
#  .                    .
# ........................#
#
# i.e. straight edges at an angle, arc (part of a circle) top
# straight edges intersect at tanget with arc
# Whole shape is symetrical about y axis
# The is a hole...and this hole is a certain distance from top (i.e. thickness of material)
#


# We need to do a bit geometry stuff before we get points
# theta = angle which the straight line makes with the horizontal
# line_radius = length (radius) of the large straight edge makes, where it links to the Arc

# Calcualte angle of sides wrt vertical
width = tvs_eng_mount_p2_base_width / 2
t1 = tvs_eng_mount_p2_radius1 / np.sqrt(width ** 2 + tvs_eng_mount_p2_base_height ** 2 - tvs_eng_mount_p2_radius1 **2 )
t2 = -tvs_eng_mount_p2_base_height / width
theta = math.atan(t1) - math.atan(t2)


# Calculate length of side
bigR = (width - tvs_eng_mount_p2_radius1 * np.sin(theta)) / np.cos(theta)


# Set the starting distance from the central axis of engine
tvs_eng_mount_p2_radial_offset = tvs_eng_mount_p1_radius + tvs_eng_mount_p1_thickness - overlap

# Create points
x = 0
y = 0 + tvs_eng_mount_p2_radial_offset
points2.append([x,y])


# Next point is some distance axially, the full width of the component.
x = x - tvs_eng_mount_p2_base_width
y = y + 00000000
points2.append([x,y])


# Next point is the straight edge, radially away and further axially to the center of the object
x = x + bigR * np.cos(theta)
y = y + bigR * np.sin(theta)
points2.append([x,y])



# Do the "arc"
r = tvs_eng_mount_p2_radius1
arc_angle = 2 * theta
segment_length = r * arc_angle 
segment_count = int(np.floor(segment_length / increment_distance))
angle = -segment_count / (segment_length / increment_distance) * arc_angle / 2
for i in range(1,segment_count):
	phi = (i / segment_count) * arc_angle
	x = -width + r * np.sin(angle + phi)
	y = tvs_eng_mount_p2_radial_offset + tvs_eng_mount_p2_base_height + r * np.cos(angle + phi)
	points2.append([x, y])


# Add the last point on the circular segment
phi = arc_angle / 2
x = -width + r * np.sin(phi)
y = tvs_eng_mount_p2_radial_offset + tvs_eng_mount_p2_base_height + r * np.cos(phi)
points2.append([x,y])



# Back down to beginning
x = 0
y = tvs_eng_mount_p2_radial_offset
points2.append([x,y])


# Generate circlular hole.
points3 = []
hole_x = -width
hole_y = tvs_eng_mount_p2_radial_offset + tvs_eng_mount_p2_base_height
r = tvs_eng_mount_p2_radius2
arc_angle = 2 * np.pi
segment_length = r * arc_angle 
segment_count = int(np.floor(segment_length / increment_distance))
for i in range(1,segment_count):
	phi = (i / segment_count) * arc_angle
	x = hole_x + r * np.sin(phi)
	y = hole_y + r * np.cos(phi)
	points3.append([x, y])



# Add the last point on the circular segment
phi = arc_angle
x = hole_x + r * np.sin(phi)
y = hole_y + r * np.cos(phi)
points3.append([x,y])


# --------------------------------------------------
# DRAW COMPONENT - P1
# --------------------------------------------------

# Now that we have all points that make up these two sketches, we create the freeCad objects
tvs_eng_mount_p1_points = []
for i in range(0, len(points)):
	x = points[i][0]
	y = points[i][1]
	tvs_eng_mount_p1_points.append(FreeCAD.Vector(float(0),y,x)) # append the coordinates


tvs_eng_mount_p1_object = Draft.makeWire(tvs_eng_mount_p1_points,closed=False,face=False,support=None)   # create the wire open
doc.recompute()

sketch_tvs_eng_mount_p1 = Draft.make_sketch([tvs_eng_mount_p1_object], autoconstraints=True, delete=False, radiusPrecision=0)
doc.recompute()


# Pad p1 component
doc.addObject('PartDesign::Body','tvs_eng_mount_p1_body')
doc.tvs_eng_mount_p1_body.Group = [sketch_tvs_eng_mount_p1]

sketch_tvs_eng_mount_p1.Support = (doc.getObject('XY_Plane043'), [''])
sketch_tvs_eng_mount_p1.MapMode = 'FlatFace'
doc.recompute()

doc.getObject('tvs_eng_mount_p1_body').newObject('PartDesign::Pad','tvs_eng_mount_p1_pad')
doc.getObject('tvs_eng_mount_p1_pad').Profile = sketch_tvs_eng_mount_p1
doc.getObject('tvs_eng_mount_p1_pad').ReferenceAxis = (sketch_tvs_eng_mount_p1, ['N_Axis'])
doc.getObject('tvs_eng_mount_p1_pad').Direction = (0, 0, 1)
doc.getObject('tvs_eng_mount_p1_pad').Midplane = 0
doc.getObject('tvs_eng_mount_p1_pad').Reversed = 0
doc.getObject('tvs_eng_mount_p1_pad').Offset = 0
doc.getObject('tvs_eng_mount_p1_pad').Type = 0
doc.getObject('tvs_eng_mount_p1_pad').Length = tvs_eng_mount_p1_height
doc.getObject('tvs_eng_mount_p1_pad').TaperAngle = 0
doc.getObject('tvs_eng_mount_p1_pad').UseCustomVector = 0
doc.getObject('tvs_eng_mount_p1_pad').AlongSketchNormal = 1
doc.getObject('tvs_eng_mount_p1_pad').UpToFace = None
doc.recompute()

sketch_tvs_eng_mount_p1.Visibility = False
doc.recompute()

tvs_eng_mount_p1_object.Visibility = False
doc.recompute()


# Move/Rotate p1 into place.
x_displacement = chamber_length - tvs_eng_mount_p1_height
doc.tvs_eng_mount_p1_body.Placement=App.Placement(App.Vector(x_displacement,0,0), App.Rotation(App.Vector(0,1,0),90), App.Vector(0,0,0))
doc.recompute()

rotation_angle = tvs_eng_mount_p1_angle / 2
doc.tvs_eng_mount_p1_body.Placement=App.Placement(App.Vector(0,0,0), App.Rotation(App.Vector(1,0,0),rotation_angle), App.Vector(0,0,0)).multiply(doc.tvs_eng_mount_p1_body.Placement)



# --------------------------------------------------
# DRAW COMPONENT - P2
# --------------------------------------------------

# Now that we have all points that make up these two sketches, we create the freeCad objects
tvs_eng_mount_p2_points = []
for i in range(0, len(points2)):
	x = points2[i][0]
	y = points2[i][1]
	tvs_eng_mount_p2_points.append(FreeCAD.Vector(x,y,float(0))) # append the coordinates


tvs_eng_mount_p2_object1 = Draft.makeWire(tvs_eng_mount_p2_points,closed=False,face=False,support=None)   # create the wire open
doc.recompute()

tvs_eng_mount_p2_points = []
for i in range(0, len(points3)):
	x = points3[i][0]
	y = points3[i][1]
	tvs_eng_mount_p2_points.append(FreeCAD.Vector(x,y,float(0))) # append the coordinates


tvs_eng_mount_p2_object2 = Draft.makeWire(tvs_eng_mount_p2_points,closed=True,face=False,support=None)   # create the wire open
doc.recompute()

sketch_tvs_eng_mount_p2 = Draft.make_sketch([tvs_eng_mount_p2_object1, tvs_eng_mount_p2_object2], autoconstraints=True, delete=False, radiusPrecision=0)
doc.recompute()


# Pad p2 component
doc.addObject('PartDesign::Body','tvs_eng_mount_p2_body')
doc.tvs_eng_mount_p2_body.Group = [sketch_tvs_eng_mount_p2]

sketch_tvs_eng_mount_p2.Support = (doc.getObject('XY_Plane043'), [''])
sketch_tvs_eng_mount_p2.MapMode = 'FlatFace'
doc.recompute()

doc.getObject('tvs_eng_mount_p2_body').newObject('PartDesign::Pad','tvs_eng_mount_p2_pad')
doc.getObject('tvs_eng_mount_p2_pad').Profile = sketch_tvs_eng_mount_p2
doc.getObject('tvs_eng_mount_p2_pad').ReferenceAxis = (sketch_tvs_eng_mount_p2, ['N_Axis'])
doc.getObject('tvs_eng_mount_p2_pad').Direction = (0, 0, 1)
doc.getObject('tvs_eng_mount_p2_pad').Midplane = 0
doc.getObject('tvs_eng_mount_p2_pad').Reversed = 0
doc.getObject('tvs_eng_mount_p2_pad').Offset = 0
doc.getObject('tvs_eng_mount_p2_pad').Type = 0
doc.getObject('tvs_eng_mount_p2_pad').Length = tvs_eng_mount_p2_thickness
doc.getObject('tvs_eng_mount_p2_pad').TaperAngle = 0
doc.getObject('tvs_eng_mount_p2_pad').UseCustomVector = 0
doc.getObject('tvs_eng_mount_p2_pad').AlongSketchNormal = 1
doc.getObject('tvs_eng_mount_p2_pad').UpToFace = None
doc.recompute()

sketch_tvs_eng_mount_p2.Visibility = False
doc.recompute()

tvs_eng_mount_p2_object1.Visibility = False
doc.recompute()

tvs_eng_mount_p2_object2.Visibility = False
doc.recompute()


# Move/Rotate p2 into place.
x_displacement = chamber_length
doc.tvs_eng_mount_p2_body.Placement=App.Placement(App.Vector(x_displacement,0,0), App.Rotation(App.Vector(0,1,0),0), App.Vector(0,0,0))
doc.recompute()

z_displacement = tvs_eng_mount_p2_sep / 2
doc.tvs_eng_mount_p2_body.Placement=App.Placement(App.Vector(0,0,z_displacement), App.Rotation(App.Vector(0,1,0),0), App.Vector(0,0,0)).multiply(doc.tvs_eng_mount_p2_body.Placement)
doc.recompute()

# CLONE tvs_eng_mount_p2_body to tvs_eng_mount_p2_body_copy
doc.addObject('PartDesign::Body','tvs_eng_mount_p2_body_copy')
doc.addObject('PartDesign::FeatureBase','tvs_eng_mount_p2_body_clone')
doc.getObject('tvs_eng_mount_p2_body_clone').BaseFeature = doc.getObject('tvs_eng_mount_p2_body')
doc.getObject('tvs_eng_mount_p2_body_clone').Placement = doc.getObject('tvs_eng_mount_p2_body').Placement
doc.getObject('tvs_eng_mount_p2_body_clone').setEditorMode('Placement',0)
doc.getObject('tvs_eng_mount_p2_body_copy').Group = [doc.getObject('tvs_eng_mount_p2_body_clone')]
doc.getObject('tvs_eng_mount_p2_body_copy').Tip = doc.getObject('tvs_eng_mount_p2_body_clone')
doc.recompute()


# Move tvs_eng_mount_p2_body_copy over!
z_displacement = -(tvs_eng_mount_p2_sep + tvs_eng_mount_p2_thickness)
doc.tvs_eng_mount_p2_body_copy.Placement=App.Placement(App.Vector(0,0,z_displacement), App.Rotation(App.Vector(0,1,0),0), App.Vector(0,0,0))
doc.recompute()



# -------------------------------------------
# Combine P1, 2 x P2 into a Group and union them...
# -------------------------------------------
doc.addObject("Part::MultiFuse","Tvc_Engine_Mount1_Fusion")
doc.Tvc_Engine_Mount1_Fusion.Shapes = [doc.tvs_eng_mount_p2_body_copy,doc.tvs_eng_mount_p2_body,doc.tvs_eng_mount_p1_body,]
doc.Tvc_Engine_Mounts.addObject(doc.Tvc_Engine_Mount1_Fusion)
doc.recompute()




# --------------------------------------------------
# Clone new tvs mount point and rotate 90 degrees.
# --------------------------------------------------
doc.addObject('PartDesign::Body','Tvc_Engine_Mount2_Fusion')
doc.addObject('PartDesign::FeatureBase','Tvc_Engine_Mount2_Fusion_clone')
doc.getObject('Tvc_Engine_Mount2_Fusion_clone').BaseFeature = doc.getObject('Tvc_Engine_Mount1_Fusion')
doc.getObject('Tvc_Engine_Mount2_Fusion_clone').Placement = doc.getObject('Tvc_Engine_Mount1_Fusion').Placement
doc.getObject('Tvc_Engine_Mount2_Fusion_clone').setEditorMode('Placement',0)
doc.getObject('Tvc_Engine_Mount2_Fusion').Group = [doc.getObject('Tvc_Engine_Mount2_Fusion_clone')]
doc.getObject('Tvc_Engine_Mount2_Fusion').Tip = doc.getObject('Tvc_Engine_Mount2_Fusion_clone')
doc.recompute()

doc.Tvc_Engine_Mount2_Fusion.Placement=App.Placement(App.Vector(0,0,0), App.Rotation(App.Vector(1,0,0),90), App.Vector(0,0,0))


# --------------------------------------------------
# Add second Tvs mount to group.
# --------------------------------------------------
doc.Tvc_Engine_Mounts.addObject(doc.Tvc_Engine_Mount2_Fusion)
doc.recompute()






# --------------------------------------------------
# Create beginnings of End Cap for Combusion Chamber and Injector holder.
# --------------------------------------------------
# Create the "disc"
Endcap_radius = combustion_chamber_external_radius + InjectorCont_flange_width
Endcap_base = doc.addObject("Part::Cylinder", "Endcap_base")
Endcap_base.Radius = Endcap_radius
Endcap_base.Height = Endcap_thickness
x_displacement = -InjectorCont_height - InjectorCont_flange_thickness
Endcap_base.Placement=App.Placement(App.Vector(x_displacement,0,0), App.Rotation(App.Vector(0,1,0),-90), App.Vector(0,0,0))
doc.recompute()



# Copy holes created previously (they need to line up)
endcap_holes_body_name = 'Endcap_bolt_holes'
clone_name = 'InjectorCont_flange_holes_clone'
doc.addObject('PartDesign::Body', endcap_holes_body_name)
doc.addObject('PartDesign::FeatureBase',clone_name)
doc.getObject(clone_name).BaseFeature = doc.getObject('injectorcont_flange_holes_fusion')
doc.getObject(clone_name).Placement = doc.getObject('injectorcont_flange_holes_fusion').Placement
doc.getObject(clone_name).setEditorMode('Placement',0)
doc.getObject(endcap_holes_body_name).Group = [doc.getObject(clone_name)]
doc.getObject(endcap_holes_body_name).Tip = doc.getObject(clone_name)
x_displacement = - InjectorCont_flange_thickness
doc.getObject(endcap_holes_body_name).Placement=App.Placement(App.Vector(x_displacement,0,0), App.Rotation(App.Vector(0,1,0),0), App.Vector(0,0,0))
doc.recompute()

# ----------------------------------------------
# Subtract holes from End Cap
# ----------------------------------------------
doc.addObject("Part::Cut","Endcap_with_holes")
doc.Endcap_with_holes.Base = Endcap_base
doc.Endcap_with_holes.Tool = doc.getObject(endcap_holes_body_name)
doc.recompute()



# ----------------------------------------------
# Endcap attachments for truss
# ----------------------------------------------

# ---------------------------------------------------------------
# Create the other component, p2 of the TVS  This radially attaches to p1 component.
# This part is created if looking from side of engine (not radially, not axially)
# 
# We only define ONE of these and we pad, rotate, etc later on.
# ---------------------------------------------------------------
points2 = []

# We visualise what this will look like
#
#           .  . 
#        .        .  
#     .      .       .
#    .      . .        .
#   .        .          .
#  .                    .
#  .                    .
# ........................#
#
# i.e. straight edges at an angle, arc (part of a circle) top
# straight edges intersect at tanget with arc
# Whole shape is symetrical about y axis
# The is a hole...and this hole is a certain distance from top (i.e. thickness of material)
#


# We need to do a bit geometry stuff before we get points
# theta = angle which the straight line makes with the horizontal
# line_radius = length (radius) of the large straight edge makes, where it links to the Arc

# Calcualte angle of sides wrt vertical
width = endcap_mount_p1_base_width / 2
t1 = endcap_mount_p1_radius1 / np.sqrt(width ** 2 + endcap_mount_p1_base_height ** 2 - endcap_mount_p1_radius1 **2 )
t2 = -endcap_mount_p1_base_height / width
theta = math.atan(t1) - math.atan(t2)


# Calculate length of side
bigR = (width - endcap_mount_p1_radius1 * np.sin(theta)) / np.cos(theta)


# joe
# Set the starting distance from the central axis of engine
endcap_mount_p1_radial_offset = combustion_chamber_external_radius + InjectorCont_flange_width - overlap

# Create points
x = 0
y = 0 + endcap_mount_p1_radial_offset
points2.append([x,y])
# print("x, y: ", x, y)



# Next point is some distance axially, the full width of the component.
x = x - endcap_mount_p1_base_width
y = y + 00000000
points2.append([x,y])
# print("x, y: ", x, y)




# Next Point is straight out (radially)
x = x - 0000000
y = y + endcap_mount_p1_height_straight
points2.append([x,y])


# Next point is the straight edge, radially away and further axially to the center of the object
x = x + bigR * np.cos(theta)
y = y + bigR * np.sin(theta)
points2.append([x,y])
# print("x, y: ", x, y)



# Do the "arc"
r = endcap_mount_p1_radius1
arc_angle = 2 * theta
segment_length = r * arc_angle 
segment_count = int(np.floor(segment_length / increment_distance))
angle = -segment_count / (segment_length / increment_distance) * arc_angle / 2
for i in range(1,segment_count):
	phi = (i / segment_count) * arc_angle
	x = -width + r * np.sin(angle + phi)
	y = endcap_mount_p1_radial_offset + endcap_mount_p1_base_height + endcap_mount_p1_height_straight + r * np.cos(angle + phi)
	points2.append([x, y])
	print("x, y: ", x, y)


# Add the last point on the circular segment
phi = arc_angle / 2
x = -width + r * np.sin(phi)
y = endcap_mount_p1_radial_offset + endcap_mount_p1_base_height + endcap_mount_p1_height_straight +  r * np.cos(phi)
points2.append([x,y])
print("x, y: ", x, y)



# Back down to beginning -1
x = 0
y = endcap_mount_p1_radial_offset + endcap_mount_p1_height_straight
points2.append([x,y])
print("x, y: ", x, y)



# Back down to beginning
x = 0
y = endcap_mount_p1_radial_offset
points2.append([x,y])
print("x, y: ", x, y)


# Generate circlular hole.
points3 = []
hole_x = -width
hole_y = endcap_mount_p1_radial_offset + endcap_mount_p1_base_height + endcap_mount_p1_base_offset + endcap_mount_p1_height_straight
r = endcap_mount_p1_radius2
arc_angle = 2 * np.pi
segment_length = r * arc_angle 
segment_count = int(np.floor(segment_length / increment_distance))
for i in range(1,segment_count):
	phi = (i / segment_count) * arc_angle
	x = hole_x + r * np.sin(phi)
	y = hole_y + r * np.cos(phi)
	points3.append([x, y])
	



# Add the last point on the circular segment
phi = arc_angle
x = hole_x + r * np.sin(phi)
y = hole_y + r * np.cos(phi)
points3.append([x,y])




# Now that we have all points that make up these two sketches, we create the freeCad objects
endcap_mount_p1_points = []
for i in range(0, len(points2)):
	x = points2[i][0]
	y = points2[i][1]
	endcap_mount_p1_points.append(FreeCAD.Vector(x,y,float(0))) # append the coordinates


endcap_mount_p1_object1 = Draft.makeWire(endcap_mount_p1_points,closed=False,face=False,support=None)   # create the wire open
doc.recompute()

endcap_mount_p1_points = []
for i in range(0, len(points3)):
	x = points3[i][0]
	y = points3[i][1]
	endcap_mount_p1_points.append(FreeCAD.Vector(x,y,float(0))) # append the coordinates


endcap_mount_p1_object2 = Draft.makeWire(endcap_mount_p1_points,closed=True,face=False,support=None)   # create the wire open
doc.recompute()

sketch_endcap_mount_p1 = Draft.make_sketch([endcap_mount_p1_object1, endcap_mount_p1_object2], autoconstraints=True, delete=False, radiusPrecision=0)
doc.recompute()



## ----------------------------------------------
# Endcap attachments for truss - Create Pads, move into position and copy/rotate
# ----------------------------------------------
doc.addObject('PartDesign::Body','endcap_mount_p1_body')
doc.endcap_mount_p1_body.Group = [sketch_endcap_mount_p1]

sketch_endcap_mount_p1.Support = (doc.getObject('XY_Plane043'), [''])
sketch_endcap_mount_p1.MapMode = 'FlatFace'
doc.recompute()

doc.getObject('endcap_mount_p1_body').newObject('PartDesign::Pad','endcap_mount_p1_pad')
doc.getObject('endcap_mount_p1_pad').Profile = sketch_endcap_mount_p1
doc.getObject('endcap_mount_p1_pad').ReferenceAxis = (sketch_endcap_mount_p1, ['N_Axis'])
doc.getObject('endcap_mount_p1_pad').Direction = (0, 0, 1)
doc.getObject('endcap_mount_p1_pad').Midplane = 0
doc.getObject('endcap_mount_p1_pad').Reversed = 0
doc.getObject('endcap_mount_p1_pad').Offset = 0
doc.getObject('endcap_mount_p1_pad').Type = 0
doc.getObject('endcap_mount_p1_pad').Length = endcap_mount_p1_thickness
doc.getObject('endcap_mount_p1_pad').TaperAngle = 0
doc.getObject('endcap_mount_p1_pad').UseCustomVector = 0
doc.getObject('endcap_mount_p1_pad').AlongSketchNormal = 1
doc.getObject('endcap_mount_p1_pad').UpToFace = None
doc.recompute()

sketch_endcap_mount_p1.Visibility = False
doc.recompute()

endcap_mount_p1_object1.Visibility = False
doc.recompute()

endcap_mount_p1_object2.Visibility = False
doc.recompute()


# Move/Rotate p1 into place.
doc.endcap_mount_p1_body.Placement=App.Placement(App.Vector(0,0,0), App.Rotation(App.Vector(0,1,0),-90), App.Vector(0,0,0))
doc.recompute()

x_displacement = -InjectorCont_height - InjectorCont_flange_thickness
z_displacement = endcap_mount_p1_base_width / 2
y_displacement = -endcap_mount_p1_height_straight
doc.endcap_mount_p1_body.Placement=App.Placement(App.Vector(x_displacement,y_displacement,z_displacement), App.Rotation(App.Vector(0,1,0),0), App.Vector(0,0,0)).multiply(doc.endcap_mount_p1_body.Placement)
doc.recompute()



# --------------------------------------------------
# Create THREE of these endcap mounts and rotate them so they are all 90 degrees apart.
# --------------------------------------------------
rotation_increment = 360 / endcap_mount_p1_count
for i in range(1,endcap_mount_p1_count):
	j = i + 1
	body_name = 'endcap_mount_p' + str(j)
	clone_name = 'endcap_mount_p1_clone' + str(j)
	doc.addObject('PartDesign::Body',body_name)
	doc.addObject('PartDesign::FeatureBase',clone_name)
	doc.getObject(clone_name).BaseFeature = doc.getObject('endcap_mount_p1_body')
	doc.getObject(clone_name).Placement = doc.getObject('endcap_mount_p1_body').Placement
	doc.getObject(clone_name).setEditorMode('Placement',0)
	doc.getObject(body_name).Group = [doc.getObject(clone_name)]
	doc.getObject(body_name).Tip = doc.getObject(clone_name)
	doc.recompute()
	
	rotation = i * rotation_increment
	print("Creating Body: ", body_name)
	doc.getObject(body_name).Placement=App.Placement(App.Vector(0,0,0), App.Rotation(App.Vector(1,0,0),rotation), App.Vector(0,0,0))




# -------------------------------------------
# Combine endcap with endcap Mounts.
# -------------------------------------------
doc.addObject("Part::MultiFuse","Endcap_Final")
doc.Endcap_Final.Shapes = [doc.getObject('endcap_mount_p1_body'), doc.getObject('endcap_mount_p2'), doc.getObject('endcap_mount_p3'), doc.getObject('endcap_mount_p4'), doc.Endcap_with_holes]
doc.recompute()





# Create the Injector.
# ------------------------------------------------------------------------
# Prompt user for Injector file
# ------------------------------------------------------------------------
file_dialog = QtGui.QFileDialog()
injector_file_path = file_dialog.getOpenFileName()[0]
print("\nImporting: " + injector_file_path + "\n")
with open(injector_file_path, "r") as read_file:
	injector_data = json.load(read_file)

print(len(injector_data))



wire = []
line_count = 0
for i in range(0, len(injector_data)):
	x = float(injector_data[i][0])
	y = float(injector_data[i][1])

	wire.append(FreeCAD.Vector(float(x),float(y),float(0))) # append the coordinates
	line_count += 1

print(f'\nProcessed {line_count} lines.\n')
wire_injector_body_object = Draft.makeWire(wire,closed=False, face=False,support=None)   # create the wire open


doc.recompute()

sketch_injector_body = Draft.make_sketch([wire_injector_body_object], autoconstraints=True, delete=False, radiusPrecision=0)
doc.recompute()